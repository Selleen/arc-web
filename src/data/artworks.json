[
  {
    "id": "A1",
    "title": "black&white_rotate",
    "artist": "Unknown",
    "repoUrl": "None",
    "year":"2020",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness", "interactions"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"black&white_rotate",
      "extension":".js",
      "content":"let canvasWidth = 800;\nlet canvasHeight = 800;\nlet topLayer;\nlet bottomLayer;\nlet startX = -canvasWidth; // Start off-screen\nlet weightDifference;\nlet blackWeight;\nlet whiteWeight;\nlet maskGraphics; \n\n\nfunction setup() {\n  createCanvas(canvasWidth, canvasHeight);\n\n  topLayer = createGraphics(canvasWidth, canvasHeight); \n  bottomLayer = createGraphics(canvasWidth, canvasHeight); \n\n  weightDifference = random(-5, 5);\n  blackWeight = random(5, 20);\n  whiteWeight = blackWeight + weightDifference;\n\n  startX = -canvasWidth; // Reset startX for drawing stripes\n\n  // Draw top layer stripes\n  while (startX < canvasWidth) {\n    // Draw black stripe\n    topLayer.stroke(0);\n    topLayer.strokeWeight(blackWeight);\n    topLayer.line(startX, 0, startX + canvasWidth, canvasHeight);\n    startX += blackWeight;\n\n    // Draw white stripe\n    topLayer.stroke(255);\n    topLayer.strokeWeight(whiteWeight);\n    topLayer.line(startX, 0, startX + canvasWidth, canvasHeight);\n    startX += whiteWeight;\n  }\n\n  startX = -canvasWidth; // Reset startX for bottom layer stripes\n\n  // Draw bottom layer stripes in the opposite diagonal direction\n  while (startX < canvasWidth) {\n    // Draw black stripe\n    bottomLayer.stroke(255);\n    bottomLayer.strokeWeight(blackWeight);\n    bottomLayer.line(startX, canvasHeight, startX + canvasWidth, 0);\n    startX += blackWeight;\n\n    // Draw white stripe\n    bottomLayer.stroke(0);\n    bottomLayer.strokeWeight(whiteWeight);\n    bottomLayer.line(startX, canvasHeight, startX + canvasWidth, 0);\n    startX += whiteWeight;\n  }\n  \n  maskGraphics = createGraphics(width, height);\n}\n\nfunction draw() {\n  image(topLayer, 0, 0); \n  image(bottomLayer, 0, 0); \n\n  // Update the mask with rotation around the canvas center\n  maskGraphics.clear(); // Clear previous frames\n  maskGraphics.fill(255); // White area defines the visible part\n\n  maskGraphics.push();\n  // Move the origin to the center of the canvas\n  maskGraphics.translate(canvasWidth / 2, canvasHeight / 2);\n  // Apply rotation\n  let angle = frameCount * 0.01; // Angle increases over time for smooth rotation\n  maskGraphics.rotate(angle);\n  // Move back to draw shapes in correct position\n  maskGraphics.translate(-canvasWidth / 2, -canvasHeight / 2);\n\n  // Draw squares\n  let halfWidth = canvasWidth / 2;\n  maskGraphics.square(halfWidth, 0, halfWidth);\n  maskGraphics.square(0, halfWidth, halfWidth);\n\n  maskGraphics.pop();\n\n  // Apply the mask to the top layer\n  let maskedLayer = topLayer.get(); // Get a copy of the top layer\n  maskedLayer.mask(maskGraphics);\n\n  // Draw the masked top layer\n  image(maskedLayer, 0, 0);\n\n  // Draw triangles in the corners of the canvas\n  noStroke();\n  triangle(0, 0, halfWidth, 0, 0, halfWidth);\n  triangle(0, halfWidth, 0, canvasHeight, halfWidth, canvasHeight);\n  triangle(halfWidth, 0, canvasWidth, 0, canvasWidth, halfWidth);\n  triangle(halfWidth, canvasHeight, canvasWidth, canvasHeight, canvasWidth, halfWidth);\n}"
    }

  },
  {
    "id": "A2",
    "title": "flowFieldNoiseAudio",
    "artist": "Unknown",
    "repoUrl": "None",
    "year":"2020",
    "classification":{
      "material_and_processes": ["processed_audio", "synthesized_image", "randomness", "interactions"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "auditory", "time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"flowFieldNoiseAudio",
      "extension":".js",
      "content":"let audioContext, analyser, dataArray, sound;\nlet num = 80;\nlet noiseScale = 0.01;\nlet particles = [];\nlet currentColor;\nlet currentIteration = 0;\nlet isPlaying = false;\n\n// Load and play an audio file\nfunction preload() {\n    soundFormats('wav');\n    sound = loadSound(\"Cornfield_Chase.mp3\", soundLoaded);\n}\n\n// Ensure user interaction before playing audio\nfunction soundLoaded() {\n    console.log(\"Audio loaded. Click to start.\");\n}\n\nfunction setup() {\n    createCanvas(1550, 900);\n    colorMode(HSB);\n    currentColor = color(0, 0, 100);\n    background(0, 0, 0);\n\n    for (let i = 0; i < num; i++) {\n        particles.push(createVector(random(width), random(height)));\n    }\n}\n\nfunction draw() {\n    if (!isPlaying) return; // Wait until audio starts\n\n    if (currentIteration % 15 === 0 && particles.length < 2000) {\n        for (let i = 0; i < num; i++) {\n            particles.push(createVector(random(width), random(height)));\n        }\n    }\n\n    background(0, 0, 0, 0.01);\n\n    if (analyser) {\n        analyser.getByteFrequencyData(dataArray);\n\n        let avgFrequency = getAverageFrequency(dataArray);\n        let hueValue = map(avgFrequency, 0, 255, 0, 360);\n        let noiseStrength = map(avgFrequency, 0, 255, 0.005, 0.3);\n        noiseScale = noiseStrength;\n\n        currentColor = color(hueValue, 100, 100);\n    }\n\n    for (let i = 0; i < particles.length; i++) {\n        stroke(currentColor);\n        let p = particles[i];\n        point(p.x, p.y);\n        let n = noise(p.x * noiseScale, p.y * noiseScale);\n        let a = TAU * n;\n        p.x += cos(a);\n        p.y += sin(a);\n\n        if (!onScreen(p)) {\n            p.x = random(width);\n            p.y = random(height);\n        }\n    }\n\n    currentIteration++;\n}\n\n// Start music on user interaction\nfunction mousePressed() {\n    if (!isPlaying) {\n        setupAudio();\n        sound.loop();\n        isPlaying = true;\n        console.log(\"Audio started.\");\n    }\n    noiseSeed(millis());\n}\n\nfunction onScreen(v) {\n    return v.x >= 0 && v.x <= width && v.y >= 0 && v.y <= height;\n}\n\nfunction setupAudio() {\n    audioContext = getAudioContext();\n    analyser = audioContext.createAnalyser();\n    analyser.fftSize = 512;\n\n    const bufferLength = analyser.frequencyBinCount;\n    dataArray = new Uint8Array(bufferLength);\n\n    sound.connect(analyser);\n    analyser.connect(audioContext.destination);\n}\n\nfunction getAverageFrequency(array) {\n    let sum = 0;\n    for (let i = 0; i < array.length; i++) {\n        sum += array[i];\n    }\n    return sum / array.length;\n}\n"
    }

  },
  {
    "id": "A3",
    "title": "plottable004",
    "artist": "Unknown",
    "repoUrl": "None",
    "year":"2020",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "static"]
    },

    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"plottable004",
      "extension":".html",
      "content":"<!DOCTYPE html>\n<html lang=\"en\">\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.11/addons/p5.dom.min.js\"></script>\n    <script src=\"https://unpkg.com/p5.js-svg@1.5.1\"></script>\n    <style>\n        body {\n            padding: 0;\n            margin: 0;\n        }\n    </style>\n</head>\n\n<body>\n    <script>\n        //297mm Ã— 420mm\n        //pixel = dpi * mm / 25.4 mm\n        //w=300*297/25.4=3507.9\n        //h=300*420/25.4=4960.2\n        var echelle = 0.5\n        var w = 1122 * echelle\n        var h = 1587 * echelle\n        var cnv, imgbtn\n\n        function setup() {\n            getsvg()\n            //getpng()\n            centerCanvas();\n            colorMode(HSB, 360, 100, 100, 250);\n            strokeCap(SQUARE)\n            initfield()\n            background(0, 0, 0)\n            noFill()\n        }\n\n        function getsvg() {\n            cnv = createCanvas(w, h, SVG);\n            imgbtn = createButton(\"save svg\");\n            placebtn();\n            imgbtn.mouseClicked(savesvg);\n        }\n\n        function getpng() {\n            cnv = createCanvas(w, h);\n            imgbtn = createButton(\"save png\");\n            placebtn();\n            imgbtn.mouseClicked(savepng);\n        }\n\n        function centerCanvas() {\n            var x = (windowWidth - w) / 2;\n            var y = (windowHeight - h) / 2;\n            cnv.position(x, y);\n        }\n\n        function placebtn() {\n            var x = (windowWidth - w) / 2;\n            var y = (windowHeight - h) / 2;\n            imgbtn.position(x - 200, y + h / 2 + 42)\n        }\n\n        function savesvg() {\n            save(\"plottable004.svg\");\n        }\n        function savepng() {\n            save(\"plottable004.png\");\n        }\n\n\n        var leftmargin = 0.1*w\n        var righttmargin = 0.9*w\n        var topmargin = 0.1*h\n        var bottommargin = 0.9*h\n        var resolution = 0.2*w\n        var field = []\n\n        function initfield() {\n            var x1, x2, y1, y2, miny, wid, hei\n            x1 = leftmargin\n            y1 = topmargin\n            x2 = x1 + Math.floor(random(3, 5)) * resolution\n            y2 = y1 + Math.floor(random(3, 5)) * resolution\n            miny = y2\n            while (y1 < bottommargin) {\n                while (x1 < righttmargin) {\n                    wid = x2 - x1\n                    hei = y2 - y1\n                    field.push({\n                        x: x1,\n                        y: y1,\n                        wid: wid,\n                        hei: hei\n                    })\n                    x1 = x2\n                    x2 = x1 + Math.floor(random(1, 4)) * resolution\n                    if (x2 > righttmargin) { x2 = righttmargin }\n                    if (miny!=y2) {//y2 != h - bottommargin\n                        y2 = y1 + Math.floor(random(1, 4)) * resolution\n                        if (y2 >=  bottommargin) { y2 = bottommargin }\n                        if (y2 < miny) { miny = y2 }\n                    }\n                    \n                }\n                x1 = leftmargin\n                y1 = miny\n                x2 = x1 + Math.floor(random(2, 5)) * resolution\n                y2 = y1 + Math.floor(random(2, 5)) * resolution\n                if (y2 >=  bottommargin) { y2 =  bottommargin }\n                miny = y2\n            }\n        }\n\n        function draw() {\n            drawfield()\n            //drawplainfield()\n            noLoop()\n        }\n\n        function drawplainfield() {\n\n            strokeWeight(15)\n            //            fill(0, 0, 100, 42)\n            //            console.log(field.length)\n            for (var i = 0; i < field.length; i++) {\n                if (i % 2 == 0) { stroke(0, 100, 100) }\n                else[stroke(180, 100, 100)]\n                var cell = field[i]\n                rect(cell.x, cell.y, cell.wid, cell.hei)\n            }\n        }\n\n        function drawfield() {\n            strokeWeight(1)\n            stroke(0, 0, 100)\n            shuffleArray(field)\n            for (var i = 0; i < field.length; i++) {\n                var cell = field[i]\n                ikeda(cell.x, cell.y, cell.wid, cell.hei)\n            }\n        }\n\n        function ikeda(x, y, wid, hei) {\n            //fill(0, 0, 0); stroke(0, 100, 100); strokeWeight(35); rect(x, y, wid, hei); noFill(); strokeWeight(1); stroke(0, 0, 100)\n            var density, offset, r, x1, x2, x3, y1, y2, y3\n            density = Math.floor(random(2, 7))\n            offset = random(1, 2)\n            r = Math.floor(random(3))\n            switch (r) {\n                case 0:\n                    for (var i = 0; i < wid / 2; i += density) {\n                        x1 = x + i; x2 = x + wid - i; x3 = x + wid;\n                        y1 = y + offset * i; y2 = y + hei - offset * i;\n                        quad(x1, y1, x2, y1, x3, y2, x1, y2)\n                    }\n                    break;\n                case 1:\n                    for (var i = 0; i < wid / 2; i += density) {\n                        x1 = x + i; x2 = x + wid - i; x3 = x;\n                        y1 = y + offset * i; y2 = y + hei - offset * i;\n                        quad(x1, y1, x2, y1, x2, y2, x3, y2)\n                    }\n                    break;\n                case 2:\n                    for (var i = 0; i < wid / 2; i += density) {\n                        x1 = x + i; x2 = x + wid - i;\n                        y1 = y + offset * i; y2 = y + hei - offset * i; y3 = y + hei\n                        quad(x1, y1, x2, y1, x2, y3, x1, y2)\n                    }\n                    break;\n            }\n        }\n\n        /* Randomize array in-place using Durstenfeld shuffle algorithm */\n        function shuffleArray(array) {\n            for (var i = array.length - 1; i > 0; i--) {\n                var j = Math.floor(Math.random() * (i + 1));\n                var temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n        }\n    </script>\n</body>\n\n</html>"
    }
  },
  {
    "id": "A4",
    "title": "sound003",
    "artist": "Unknown",
    "repoUrl": "None",
    "year":"2020",
    "classification":{
      "material_and_processes": ["synthesized_sound"], 
      "interaction": ["human_interaction"], 
      "outcome": ["auditory","visual","time_based"]
    },

    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"sound003",
      "extension":".html",
      "content":"<!DOCTYPE html>\n<html lang=\"en\">\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <script src=\"https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js\"></script>\n    <script src=\"libraries/StartAudioContext.js\"></script>\n    <style>\n        body {\n            padding: 0;\n            margin: 0;\n        }\n    </style>\n</head>\n\n<body>\n    <script>\n        let canvas;\n        var w = document.documentElement.clientWidth;//width of window that is available for drawing\n        var h = document.documentElement.clientHeight;//width of window that is available for drawing\n        var soundOn = false;\n        var osc1,osc2,osc3;\n        var wave1,wave2;\n\n        function setup() {\n            colorMode(HSB, 360, 100, 100)\n            canvas = createCanvas(w, h);\n            background(0, 0, 0);\n\n            osc1 = new Tone.Oscillator();\n            osc1.toDestination();\n            osc1.volume.value=-15\n            osc2 = new Tone.Oscillator();\n            osc2.frequency.value=110;\n            osc2.toDestination();\n            osc2.volume.value=-22\n            \n            wave1=new Tone.Waveform()\n            wave2=new Tone.Waveform()\n            osc1.connect(wave1)\n            osc2.connect(wave2)\n            //Tone.Master.volume.value=-3;\n        }\n        function mousePressed() {\n            if (!soundOn) {\n                soundOn = true\n                osc1.start()\n                osc2.start()\n            }\n        }\n\n        function draw() {\n            background(0, 0, 0);\n            if (!soundOn) {\n                fill(50, 100, 100); stroke(50, 100, 100);\n                textSize(42)\n                textAlign(\"center\")\n                text(\"click to start\", w / 2, h / 2);\n            }\n            else {\n                osc1.frequency.value= map(mouseX,0,w,110,880)\n                osc2.frequency.value= map(mouseY,0,h,110,330)\n                //displayWaves();\n                displayWavesCircle();\n            }\n        }\n\n        function displayWaves(){\n                let buffer1 = wave1.getValue(0)\n                let buffer2 = wave2.getValue(0)\n                let start1 = 0;\n                for (i=1;i<buffer1.length;i++){\n                    if(buffer1[i-1]<0 && buffer1[i]>=0){\n                        start1=i;\n                        break\n                    }\n                }\n                let start2 = 0;\n                for (i=1;i<buffer2.length;i++){\n                    if(buffer2[i-1]<0 && buffer2[i]>=0){\n                        start2=i;\n                        break\n                    }\n                }\n                let end1 = start1 + buffer1.length/2;\n                let end2 = start2 + buffer2.length/2;\n                for (i=start1;i<end1;i++){\n                    let x1 = map(i-1,start1,end1,0,w)\n                    let y1 = map(buffer1[i-1],-1,1,0,h)\n                    let x2 = map(i,start1,end1,0,w)\n                    let y2 = map(buffer1[i],-1,1,0,h)\n                    stroke(0,100,100)\n                    line(x1,y1,x2,y2)\n                }\n                for (t=start2;t<end2;t++){\n                    let x1 = map(t-1,start2,end2,0,w)\n                    let y1 = map(buffer2[t-1],-1,1,0,h)\n                    let x2 = map(t,start2,end2,0,w)\n                    let y2 = map(buffer2[t],-1,1,0,h)\n                    stroke(180,100,100)\n                    line(x1,y1,x2,y2) \n                }\n        }\n\n        function displayWavesCircle(){\n                noStroke()\n                let buffer1 = wave1.getValue(0)\n                let buffer2 = wave2.getValue(0)\n                let start1 = 1;\n                let start2 = 1\n                let end1 = buffer1.length;\n                let end2 = buffer2.length;\n                let a_step=2*PI/(end1-start1);\n                let angle = 0\n                for (i=start1;i<end1;i++){\n                    let x1 = w/2 + h/2*cos(angle)\n                    let y1 = h/2+map(buffer1[i-1],-1,1,0,h/2)*sin(angle)\n                    let x2 = w/2 + h/2*cos(angle+a_step)\n                    let y2 = h/2+map(buffer1[i],-1,1,0,h)*sin(angle+a_step)\n                    angle+=a_step\n                    fill(180,100,100); ellipse(x1,y1,5,5)\n                    fill(230,100,100); ellipse(x2,y2,5,5)\n                }\n                a_step=2*PI/(end1-start1);\n                angle=0\n                for (t=start2;t<end2;t++){\n                    let x1 = w/2 + h/2*cos(angle)\n                    let y1 = h/2+map(buffer2[t-1],-1,1,0,h/2)*sin(angle)\n                    let x2 = w/2 + h/2*cos(angle+a_step)\n                    let y2 = h/2+map(buffer2[t],-1,1,0,h)*sin(angle+a_step)\n                    angle+=a_step\n                    fill(0,100,100); ellipse(x1,y1,5,5)\n                    fill(50,100,100); ellipse(x2,y2,5,5)\n                }\n        }\n\n        function windowResized() {\n            w = document.documentElement.clientWidth;//width of window that is available for drawing\n            h = document.documentElement.clientHeight;//width of window that is available for drawing\n            resizeCanvas(w, h);\n        }\n\n    </script>\n</body>\n\n</html>"
    }

  },
  {
    "id": "A5",
    "title": "vertical_BW_stripes",
    "artist": "Unknown",
    "year": "2020",
    "repoUrl": "None",
    "classification":{
      "material_and_processes": ["synthesized_image", "interactions"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]
    },

    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"vertical_BW_stripes",
      "extension":".js",
      "content":"let topLayer; // Top striped layer (starting with black)\nlet bottomLayer; // Bottom striped layer (starting with white)\nlet maskGraphics; // Graphics to create the circular mask\nlet stripeWidth = 20; // Width of each stripe\n\nfunction setup() {\n  createCanvas(1200, 600);\n  // noLoop();\n\n  // Create the top layer with black and white stripes (starting with black)\n  topLayer = createGraphics(width, height);\n  for (let x = 0; x < width; x += stripeWidth) {\n    if ((x / stripeWidth) % 2 === 0) {\n      topLayer.fill(0); // Black stripe\n    } else {\n      topLayer.fill(255); // White stripe\n    }\n    topLayer.noStroke();\n    topLayer.rect(x, 0, stripeWidth, height);\n  }\n\n  // Create the bottom layer with black and white stripes (starting with white)\n  bottomLayer = createGraphics(width, height);\n  for (let x = 0; x < width; x += stripeWidth) {\n    if ((x / stripeWidth) % 2 === 0) {\n      bottomLayer.fill(255); // White stripe\n    } else {\n      bottomLayer.fill(0); // Black stripe\n    }\n    bottomLayer.noStroke();\n    bottomLayer.rect(x, 0, stripeWidth, height);\n  }\n\n  // Create the circular mask\n  maskGraphics = createGraphics(width, height);\n  maskGraphics.noFill();\n  maskGraphics.ellipseMode(CENTER);\n}\n\nfunction draw() {\n  background(0);\n\n  // Draw the bottom layer\n  image(bottomLayer, 0, 0);\n\n//   // Update the mask with a moving circle\n  maskGraphics.clear(); // Clear previous frames\n  maskGraphics.fill(255); // White area defines the visible part\n  let circleX = mouseX;\n  let circleY = mouseY;\n  let circleDiameter = 150;\n  maskGraphics.ellipse(circleX, circleY, circleDiameter);\n\n  // Apply the mask to the top layer\n  let maskedLayer = topLayer.get(); // Get a copy of the top layer\n  maskedLayer.mask(maskGraphics);\n\n  // Draw the masked top layer\n  image(maskedLayer, 0, 0);\n}\n"
    }

  },
  {
    "id": "A6",
    "title": "akuru",
    "artist": "Unknown",
    "year": "2020",
    "repoUrl": "None",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"akuru",
      "extension":".js",
      "content":"let s, lines = [], seed, dir = 1, amt = 0, numPoints = 200;\nlet linesConfig = [];\nlet maxDist, segSize, tCount;\n\nfunction setup() {\n    createCanvas(500, 400);\n    colorMode(HSB, 360, 100, 100, 100);\n    frameRate(10);\n    seed = random(100);\n    lines = [];\n    amt = 0;\n    linesConfig = [];\n    maxDist = width / numPoints * 3;\n    tCount = Math.floor(width / 1.5);\n    segSize = numPoints / tCount;\n    const numLines = 8;\n    const gap = Math.floor(height / numLines);\n    const baseColor = [[0, 0, 0], [0, 100, 100], [240, 100, 100]];\n    for (let i = 0; i < numLines; i++) {\n        const yPos = i * gap;\n        linesConfig.push({x1: 0, y1: yPos, x2: width, y2: yPos, color: random(baseColor)});\n    }\n\n    lines = linesConfig.map(config => {\n        const points = new Array(numPoints + 1);\n        const x1 = config.x1;\n        const y1 = config.y1;\n        const x2 = config.x2;\n        const y2 = config.y2;\n        const invNumPoints = 1 / numPoints;\n        for (let i = 0; i <= numPoints; i++) {\n            const t = i * invNumPoints;\n            const x = x1 + (x2 - x1) * t;\n            const y = y1 + (y2 - y1) * t;\n            points[i] = {\n                x: x,\n                y: y,\n                bx: x,\n                by: y\n            };\n        }\n        return {\n            points: points,\n            color: config.color\n        };\n    });\n\n    setTimeout(() => {\n        noLoop();\n      }, 90000);\n}\n\nfunction processLine(points, x1, y1, x2, y2) {\n    const tCountInv = 1 / (tCount - 1);\n    const maxRAmt = width * 0.10 * amt;\n    const TWO_PI_constant = TWO_PI;\n    const PI_constant = Math.PI;\n    \n    for(let i = 0; i < tCount; i++) {\n        const st = Math.floor(i * segSize);\n        const ed = Math.floor((i + 1) * segSize);\n        const cx = x1 + (x2 - x1) * i * tCountInv;\n        const cy = y1 + (y2 - y1) * i * tCountInv;\n        const r = Math.min(maxRAmt, cx, cy, width - cx, height - cy);\n        const stToEdRange = 1 / Math.max(1, ed - st);\n        for(let j = st; j <= ed; j++) {\n            const t = (j - st) * stToEdRange;\n            const spiralT = 0.1 + 0.5 * t;\n            const baseAngle = random(\n                spiralT * TWO_PI_constant * 1.5 + \n                Math.sin(spiralT * PI_constant * 1.2) + \n                i * TWO_PI_constant\n            );\n            const sinBaseAngle = Math.sin(baseAngle);\n            const cosBaseAngle = Math.cos(baseAngle);\n            const sinTerm = sinBaseAngle * Math.cos(spiralT * PI_constant * 5) * 25 * amt;\n            const noiseTerm = noise(t * 3 + seed, j * 0.02) * 1.5;\n            const radius = r * (0.3 + spiralT * 0.7) + sinTerm + noiseTerm;\n            points[j].x = cx + radius * cosBaseAngle;\n            points[j].y = cy + radius * sinBaseAngle;\n        }\n    }\n}\n\nfunction applyConstraints(points) {\n    const maxDistSq = maxDist * maxDist;\n    const halfCorrection = 0.5;\n    \n    for(let iter = 0; iter < 8; iter++) {\n        for(let i = 1; i < points.length - 1; i++) {\n            const p = points[i];\n            const prev = points[i - 1];\n            const dx = p.x - prev.x;\n            const dy = p.y - prev.y;\n            const distSq = dx * dx + dy * dy;\n            if(distSq > maxDistSq) {\n                const s = maxDist / Math.sqrt(distSq);\n                const correction = (1 - s) * halfCorrection;\n                const dxCorrection = dx * correction;\n                const dyCorrection = dy * correction;\n                \n                prev.x += dxCorrection;\n                prev.y += dyCorrection;\n                p.x -= dxCorrection;\n                p.y -= dyCorrection;\n            }\n        }\n    }\n}\n\nfunction draw() {\n    push();\n    fill(42, 10, 93).stroke(0).rect(0, 0, width, height);\n    amt = Math.min((amt + 0.005 * dir), 1);\n    for(let i = 0; i < lines.length; i++) {\n        const points = lines[i].points;\n        for(let j = 0; j < points.length; j++) {\n            const p = points[j];\n            p.x = p.bx;\n            p.y = p.by;\n        }\n    }\n    \n    for(let idx = 0; idx < lines.length; idx++) {\n        const lineObj = lines[idx];\n        const config = linesConfig[idx];\n        processLine(lineObj.points, config.x1, config.y1, config.x2, config.y2);\n        applyConstraints(lineObj.points);\n    }\n    \n    push();\n    // drawingContext.beginPath();\n    // drawingContext.moveTo(s.x1, s.y1);\n    // drawingContext.lineTo(s.x2, s.y2);\n    // drawingContext.lineTo(width, height);\n    // drawingContext.lineTo(s.x3, s.y3);\n    // drawingContext.lineTo(s.x4, s.y4);\n    // drawingContext.closePath();\n    // drawingContext.clip();\n    \n    noFill();\n    strokeWeight(2);\n    push();\n    for(let i = 0; i < lines.length; i++) {\n        const lineObj = lines[i];\n        const color = lineObj.color;\n        const points = lineObj.points;\n        stroke(color[0], color[1], color[2]);\n        beginShape();\n        if (points.length > 2) {\n            curveVertex(points[0].x, points[0].y);\n        }\n        for(let j = 0; j < points.length; j++) {\n            curveVertex(points[j].x, points[j].y);\n        }\n        if (points.length > 2) {\n            curveVertex(points[points.length-1].x, points[points.length-1].y);\n        }\n        endShape();\n    }\n    \n    pop();\n    pop();\n    pop();\n}\n"
    }

  },
  {
    "id": "A7",
    "title": "gaspe004",
    "artist": "Unknown",
    "year": "2020",
    "repoUrl": "None",
    "classification":{
      "material_and_processes": ["synthesized_image","processed_text","randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual","static"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"gaspe004",
      "extension":".js",
      "content":"function savesvg() {\n    save(\"gaspe004.svg\");\n}\n\nfunction savepng() {\n    save(\"gaspe004.png\");\n}\n\nvar font, posx, posy, knobs = [], grid = []\nvar fSize = 10\nvar stepsize = Math.floor(actualwidth * 0.01)\nvar nbhorizontalsteps = Math.floor(actualwidth / stepsize)\nvar nbvertcicalsteps = Math.floor(actualheight / stepsize)\nfunction preload() {\n    font = loadFont(\"../fonts/1CAMBam_Stick_9.ttf\");\n    sourcecode = loadStrings('gaspe004.js');\n\n}\n\nfunction draw() {\n    background(0, 0, 100)\n    stroke(0,0,0)\n    section()\n    stripes()\n    stroke(0,100,100);backgrid()\n    stroke(0,0,0)\n    textFont(font)\n    textSize(fSize)\n    showknobs()\n    showcode()\n    showcredits()\n    noLoop()\n}\n\nfunction saveknob(name, value) {\n    knobs.push({ name: name, value: value.toFixed(2) })\n}\n\nfunction backgrid() {\n    var yoff=0.0\n    var xoff\n    var inc=0.1\n    var v,x,y\n    for (j = 0; j < nbvertcicalsteps; j++) {\n        yoff+=inc\n        xoff=0.0\n        for (i = 0; i < nbhorizontalsteps; i++) {\n            x=leftmargin+i*stepsize\n            y=topmargin+j*stepsize\n            xoff+=inc\n            v=noise(xoff,yoff)\n            grid.push(v)\n            if((v>0.11 && v<0.32) || (v>0.52 && v<0.73)){\n                ellipse(x+stepsize*0.5,y+stepsize*0.5,stepsize*v,stepsize*v)}\n        }\n    }\n}\n\nfunction section(){\n    var x1,y1,x2,y2,x3,y3,xi,yi,xd,yd\n    x1=leftmargin\n    y1=topmargin\n    x2=leftmargin\n    y2=topmargin+random(0.7,0.8)*actualheight\n    x3=leftmargin+random(0.6,0.7)*actualwidth\n    y3=topmargin\n    for(t1=0;t1<1;t1+=0.005){\n        xi=(1 - t1) * x1 + (t1 * x3)\n        yi=y3\n        xd=x2\n        yd=(1 - t1) * y1 + (t1 * y2)\n        line(xi,yi,xd,yd)\n    }\n}\n\nfunction stripes(){\n    var x1,y1,x2,y2,x3,y3,x4,y4,xi,yi,xd,yd\n    var xratio=random(0.21,0.42)\n    x1=leftmargin+xratio*actualwidth\n    y1=topmargin+random(0.7,0.8)*actualheight\n    x2=leftmargin\n    y2=bottommargin\n    x3=rightmargin-xratio*actualwidth\n    y3=bottommargin\n    x4=rightmargin\n    y4=topmargin+random(0.4,0.5)*actualheight\n    bottompart(x1,y1,x2,y2,x3,y3,x4,y4)\n    y1-=0.03*actualheight\n    x2=leftmargin+random(0.7,0.8)*actualwidth\n    y2=topmargin\n    x3=rightmargin\n    y3=topmargin\n    y4-=0.03*actualheight\n    toppart(x1,y1,x3,y3,x2,y2,x4,y4)\n}\n\nfunction toppart(x1,y1,x3,y3,x2,y2,x4,y4){\n    var croise=intersect(x1,y1,x3,y3,x2,y2,x4,y4)\n    var max=x3-x2\n    var step=3\n    for(var i=0;i<17;i+=1){\n        x1+=step;y1-=step;x2+=step;y2+=step;x3-=step;y3+=step;x4-=step;y4-=step\n        quad(x1,y1,x2,y2,x3,y3,x4,y4)\n    }\n    for(var j=1;j<max;j+=step){\n        ellipse(croise.x,croise.y,j,j)\n    }\n    /*var croise=intersect(x1,y1,x3,y3,x2,y2,x4,y4)\n    var max=x3-x2\n    for(t1=0;t1<1;t1+=0.01){\n        xd=(1 - t1) * x1 + (t1 * x2)\n        yd=(1 - t1) * y1 + (t1 * y2)\n        line(croise.x,croise.y,xd,yd)\n        xd=(1 - t1) * x2 + (t1 * x3)\n        yd=(1 - t1) * y2 + (t1 * y3)\n        line(croise.x,croise.y,xd,yd)\n        xd=(1 - t1) * x3 + (t1 * x4)\n        yd=(1 - t1) * y3 + (t1 * y4)\n        line(croise.x,croise.y,xd,yd)\n        xd=(1 - t1) * x4 + (t1 * x1)\n        yd=(1 - t1) * y4 + (t1 * y1)\n        line(croise.x,croise.y,xd,yd)\n    }*/\n}\n\nfunction bottompart(x1,y1,x2,y2,x3,y3,x4,y4){\n    let off=3\n    for(i=0;i<47;i++){\n        line(x1+(i*off),y1+(i*off),x2+(i*1.5*off),y2-(i*off))\n        line(x2+(i*1.5*off),y2-(i*off),x3-(i*off),y3-(i*off))\n        line(x3-(i*off),y3-(i*off),x4-(i*off),y4+((i+1)*off))\n        line(x4-(i*off),y4+((i+1)*off),x1+((i+1)*off),y1+((i+1)*off))  \n    }\n\n}\n/*function by Paul Bourke\nhttps://paulbourke.net/geometry/pointlineplane/javascript.txt\nreturns coordinates where two segments [x1, y1, x2, y2] and [x3, y3, x4, y4] intersect*/\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n\n    // Check if none of the lines are of length 0\n      if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n          return false\n      }\n  \n      denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))\n  \n    // Lines are parallel\n      if (denominator === 0) {\n          return false\n      }\n  \n      let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator\n      let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator\n  \n    // is the intersection along the segments\n      if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n          return false\n      }\n  \n    // Return a object with the x and y coordinates of the intersection\n      let x = x1 + ua * (x2 - x1)\n      let y = y1 + ua * (y2 - y1)\n  \n      return {x, y}\n  }\n\n\nfunction showcredits() {\n    var c = \"al.my.re :: p5.js :: CamBam Stick [gaspe 004). May 2024]\"\n    text(c, posx, posy)\n}"
    }

  },
  {
    "id": "A8",
    "title": "kurutu",
    "artist": "Unknown",
    "year": "2020",
    "repoUrl": "None",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"kurutu",
      "extension":".js",
      "content":"let s, seed, dir = 1, amt = 0, numPoints = 900;\nconst clrs = [[330,40,70],[355,40,85],[24,50,95],[43,40,95]];\nlet pointsLists = [];\n\nfunction setup() {\n    createCanvas(500, 400);\n    colorMode(HSB, 360, 100, 100, 100);\n    frameRate(5);\n    seed = random(100);\n    pointsLists = [];\n    amt = 0;\n    \n    for (let i = 0; i < 5; i++) {\n        pointsLists[i] = Array.from({length: 901}, (_, j) => {\n            return {\n                x: lerp(0, width, j/numPoints),\n                y: lerp(0, height, j/numPoints),\n                bx: lerp(0, width, j/numPoints),\n                by: lerp(0, height, j/numPoints)\n            };\n        });\n    }\n}\n\nfunction draw() {\n    push();\n    fill(0).stroke(0).rect(0, 0, width, height);\n    background(0);\n    push();\n    // drawingContext.beginPath();\n    // drawingContext.moveTo(s.x1, s.y1);\n    // drawingContext.lineTo(s.x2, s.y2);\n    // drawingContext.lineTo(s.x3, s.y3);\n    // drawingContext.lineTo(s.x4, s.y4);\n    // drawingContext.closePath();\n    // drawingContext.clip();\n    \n    amt = Math.min((amt + 0.02 * dir), 1);\n    \n    // Reset base points\n    pointsLists.forEach(points => {\n        points.forEach(p => {\n            p.x = p.bx;\n            p.y = p.by;\n        });\n    });\n    const tCount = Math.max(1, floor(width / 15));\n    const segSize = numPoints / tCount;\n    const r = Math.min(height * 0.2, width * 0.2);\n\n    const multipliers = [\n        [0, 0], [-1.5, -1.5], [1.5, 1.5], [3, 3], [-3, -3], [4.5, 4.5], [-4.5, -4.5], [6, 6], [-6, -6]\n    ];\n    for (let i = 0; i < tCount; i++) {\n        let st = Math.floor(i * segSize);\n        let ed = Math.floor((i + 1) * segSize);\n        \n        const centers = multipliers.map(m => {\n            return {\n                x: lerp(0 + m[0]*r, width + m[0]*r, i / (tCount - 1)),\n                y: lerp(0 + m[1]*r, height + m[1]*r, i / (tCount - 1))\n            };\n        });\n        for (let j = st; j <= ed; j++) {\n            let t = (j - st) / (ed - st);\n            let spiralT = lerp(0.4, 0.8, t);\n            let baseAngle = random(spiralT * TWO_PI + Math.sin(spiralT * Math.PI) + i * TWO_PI);\n            let radius = r * (0.3 + spiralT * 0.7) + \n                Math.sin(baseAngle) * Math.cos(spiralT * Math.PI * 4) * 20 * amt + \n                noise(t * 3 + seed, j * 0.01);\n            \n            for (let k = 0; k < pointsLists.length; k++) {\n                pointsLists[k][j].x = centers[k].x + radius * Math.cos(baseAngle);\n                pointsLists[k][j].y = centers[k].y + radius * Math.sin(baseAngle);\n            }\n        }\n    }\n\n    //noFill();\n    for (let i = 0; i < 10; i++) {\n        const c = clrs[i % 4];\n        stroke(c[0], c[1] * 0.8, Math.min(c[2] + 10, 100), 200);\n        strokeWeight(2);\n        beginShape();\n        const segment = pointsLists[0].slice(i * (numPoints / 8), (i + 1) * (numPoints / 8) + 1);\n        segment.forEach(p => vertex(p.x, p.y));\n\n        for (let k = 1; k < pointsLists.length; k++) {\n            const segmentK = pointsLists[k].slice(i * (numPoints / 8), (i + 1) * (numPoints / 8) + 1);\n            segmentK.forEach(p => vertex(p.x, p.y));\n        }\n        \n        endShape();\n    }\n    pop();\n    pop();\n}\n"
    }

  },

  {
    "id": "A9",
    "title": "papissa",
    "artist": "Unknown",
    "year": "2020",
    "repoUrl": "None",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "static"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"papissa",
      "extension":".js",
      "content":"const N = 7;\nlet paths = [];\nlet colors;\nlet randomColorIndices = [];\n\nfunction setup() {\n    createCanvas(700, 350);\n    pixelDensity(3);\n    noLoop();\n    //noFill();\n    colors = [\n        color(119, 146, 190),  \n        color(110, 148, 245), \n        color(127, 166, 204),  \n        color(162, 161, 141),   \n        color(154, 154, 126)\n    ];\n    randomColorIndices = Array(40).fill(0).map(() => floor(random(colors.length)));\n    findPaths([0, 0], [[0, 0]]);\n    shuffle(paths, true);\n}\n\nfunction draw() {\n    background(29, 42, 54);\n    noFill();\n    stroke(112, 2, 30);\n    strokeWeight(8);\n    // red rectangle\n    rect(width - 680, height - 340, width - 40, height - 20);\n    drawRectangularBorder(width - 650, height - 320, width - 100, height - 60);\n    // width and height variables don't really do anything\n    let innerX = width - 550;\n    let innerY = height - 270;\n    let innerW = 400;\n    let innerH = 190;\n    let n = 8;\n    let sw = innerW / (n * 2 * N + 2);\n    strokeWeight(sw);\n    stroke(76, 76, 68);\n    // second gold(ish) border\n    rect(innerX, innerY, innerW, innerH);\n    // just to make the recatngulars fit nicely\n    let newInnerX = innerX + 50;\n    let newInnerY = innerY + 40;\n    let newInnerW = 300;\n    let newInnerH = 110;\n    // third gold(ish) border\n    rect(newInnerX, newInnerY, newInnerW, newInnerH);\n    drawRhombusPacking(innerX, innerY, innerW, innerH, newInnerX, newInnerY, newInnerW, newInnerH);\n    let centerX = width / 2;\n    let centerY = height / 2;\n    let maxRadius = min((width - 200) / 2.5, (height - 100) / 2.5);\n    drawCircularLines(centerX, centerY, maxRadius);\n    push();\n    translate(centerX, centerY);\n    drawDynamicCenter(maxRadius * 0.8);\n    pop();\n}\n\nfunction drawCircularLines(centerX, centerY, radius) {\n    let segments = 24;\n    let angleStep = TWO_PI / segments;\n    for (let i = 0; i < segments; i++) {\n        let angle = i * angleStep;\n        if (\n            (angle >= 0 && angle < 0.5) || \n            (angle > 2.8 && angle < 3) || \n            (angle > 3 && angle < 3.5) ||\n            (angle > 6.0 && angle < 6.5)\n        ) {\n            stroke(colors[i % colors.length]);\n            strokeWeight(1.5);\n            let x1 = centerX + cos(angle) * (radius - 20);\n            let y1 = centerY + sin(angle) * (radius - 20);\n            let x2 = centerX + cos(angle) * (radius + 50);\n            let y2 = centerY + sin(angle) * (radius + 50);\n            for (let j = 0; j < 7; j++) {\n                let t = j / 7;\n                let x = lerp(x1, x2, t);\n                let y = lerp(y1, y2, t);\n                circle(x, y, 3);\n            }\n        }\n    }\n}\n\nfunction drawDynamicCenter(radius) {\n    let numTriangles = 30;\n    let angleStep = TWO_PI / numTriangles;\n    //0.4\n    //0.5\n    let triHeight = radius * 0.6;\n    let triWidth = radius * 0.15;\n    for (let i = 0; i < numTriangles; i++) {\n        let angle = i * angleStep;\n        stroke(colors[randomColorIndices[i]]);\n        push();\n        rotate(angle);\n        triangle(0, 0, -triWidth, triHeight, triWidth, triHeight);\n        pop();\n    }\n}\n\nfunction drawRhombusPacking(innerX, innerY, innerW, innerH, newInnerX, newInnerY, newInnerW, newInnerH) {\n    let rhombuses = [];\n    let attempts = 0;\n    while (attempts < 500) {\n        let size = random(5, 15);\n        // because we go - and + after translate\n        let x = random(innerX + size, innerX + innerW - size);\n        let y = random(innerY + size, innerY + innerH - size);\n        let insideOuter = x > innerX + size && x < innerX + innerW - size && y > innerY + size && y < innerY + innerH - size;\n        let outsideInner = x < newInnerX - size || x > newInnerX + newInnerW + size || y < newInnerY - size || y > newInnerY + newInnerH + size;\n        if (insideOuter && outsideInner) {\n            let overlapping = false;\n            for (let rhombus of rhombuses) {\n                let dx = Math.abs(x - rhombus.x);\n                let dy = Math.abs(y - rhombus.y);\n                if (dx < size + rhombus.size && dy < size + rhombus.size) {\n                    overlapping = true;\n                    break;\n                }\n            }\n            if (!overlapping) {\n                rhombuses.push({ x, y, size });\n            }\n        }\n        attempts++;\n    }\n\n    for (let rhombus of rhombuses) {\n        push();\n        translate(rhombus.x, rhombus.y);\n        noStroke();\n        //strokeWeight(1.5);\n        //stroke(colors[rhombuses.indexOf(rhombus) % colors.length]);\n        //fill(colors[rhombuses.indexOf(rhombus) % colors.length]);\n        let baseColor = color(colors[rhombuses.indexOf(rhombus) % colors.length]);\n        baseColor.setAlpha(200);\n        fill(baseColor);\n        beginShape();\n        vertex(-rhombus.size, 0);\n        vertex(0, -rhombus.size);\n        vertex(rhombus.size, 0);\n        vertex(0, rhombus.size);\n        endShape(CLOSE);\n        pop();\n        baseColor.setAlpha(255);\n    }\n}\n\nfunction drawRectangularBorder(x0, y0, w, h) {\n    let n = 8;\n    let sw = w / (n * 2 * N + 2);\n    strokeWeight(sw);\n    stroke(76, 76, 68);\n    // first gold(ish) border\n    rect(x0, y0, w, h);\n    // because we want to make rect shapes\n    let sWidth = (w - 2 * sw) / n;\n    let sHeight = (h - 2 * sw) / n;\n    y0 += 3;\n    strokeWeight(Math.min(sWidth, sHeight) / (4 * N));\n    // upper horizontal\n    for (let i = 0; i < n; i++) {\n        let x = x0 + sWidth * i;\n        makeTile(x, y0, sWidth, sHeight, i);\n    }\n    // right vertical\n    for (let i = 1; i < n; i++) {\n        let y = y0 + sHeight * i;\n        makeTile(x0 + w - sWidth - 2 * sw, y, sWidth, sHeight, i + n);\n    }\n    // lower horizontal\n    for (let i = 1; i < n; i++) {\n        let x = x0 + w - sWidth * (i + 1);\n        makeTile(x - 2 * sw, y0 + h - sHeight - 2 * sw, sWidth, sHeight, i + 2 * n);\n    }\n    // left vertical\n    for (let i = 1; i < n - 1; i++) {\n        let y = y0 + h - sHeight * (i + 1);\n        makeTile(x0, y - 2 * sw, sWidth, sHeight, i + 3 * n);\n    }\n}\n\nfunction makeTile(x0, y0, sWidth, sHeight, index) {\n    let path = paths[index];\n    // change N to update the tile size and then pack more by updating n\n    let newSWidth = sWidth / N;\n    let newSHeight = sHeight / N;\n    // make k+n to have diagonal lines\n    for (let k = 0; k < path.length - 1; k++) {\n        let [i1, j1] = path[k];\n        let [i2, j2] = path[k + 1];\n        let x1 = i1 * newSWidth;\n        let y1 = j1 * newSHeight;\n        let x2 = i2 * newSWidth;\n        let y2 = j2 * newSHeight;\n        let colorIndex = (index + k) % colors.length;\n        stroke(colors[colorIndex]);\n        line(x0 + x1 + newSWidth, y0 + y1 + newSHeight, x0 + x2 + newSWidth, y0 + y2 + newSHeight);\n    }\n}\n\nfunction possibleNeighbors([i, j]) {\n    let possibilities = [];\n    if (i % 2 == 0 && j < N-1) possibilities.push([i, j+1]);\n    if (i % 2 == 1 && j > 0) possibilities.push([i, j-1]);\n    if (j % 2 == 0 && i < N-1) possibilities.push([i+1, j]);\n    if (j % 2 == 1 && i > 0) possibilities.push([i-1, j]);\n    return possibilities;\n}\n  \nfunction inArray([i, j], arr) {\n    for (let e of arr) {\n        if (e[0] == i && e[1] == j) return true;\n    }\n    return false;\n}\n\nfunction findPaths(p, visited) {\n    let neighbors = possibleNeighbors(p);\n    if (neighbors.length == 0) {\n        if (visited.length == sq(N)) paths.push(visited);\n        return;\n    }\n    for (let neigh of neighbors) {\n        if (!inArray(neigh, visited)) findPaths(neigh, [...visited, neigh]);\n    }\n}\n"
    }
  },
  {
    "id": "A10",
    "title": "para",
    "artist": "Unknown",
    "year": "2020",
    "repoUrl": "None",
    "classification":{
      "material_and_processes": ["synthesized_image","randomness"], 
      "interaction": ["computer_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"para",
      "extension":".js",
      "content":"let points1 = [];\nlet points2 = [];\nlet shapes1 = [];\nlet shapes2 = [];\nlet width = 1400;\nlet height = 800;\nlet jsonData1;\nlet jsonData2;\nlet records1 = [];\nlet records2 = [];\nlet maxEvents1 = 0;\nlet maxEvents2 = 0;\n\nconst config = {\n  n: 0,\n  maxTrials: 0,\n  r: 0.65,\n  angle: 0.03,\n  pBranch: 0.01,\n  lineSize: 1,\n  shapeSize: 4,\n  minShapeDistance: 8\n};\n\nconst categoryShapes = {\n  FileRead: drawTriangle,\n  FileWrite: drawSquare,\n  ProcessStart: drawPentagon,\n  NetworkAccess: drawHexagon\n};\n\nlet currentRecordIndex1 = 0;\nlet currentRecordIndex2 = 0;\n\nfunction preload() {\n  jsonData1 = loadJSON('data/pdf-test.json');\n  jsonData2 = loadJSON('data/pdf-prod.json');\n}\n\nfunction setup() {\n  createCanvas(width, height);\n  background('#1A1A1A');\n\n  for (let key in jsonData1) {\n    records1 = records1.concat(jsonData1[key]);\n  }\n  maxEvents1 = records1.reduce((max, record) => Math.max(max, record.events.length), 0);\n\n  for (let key in jsonData2) {\n    records2 = records2.concat(jsonData2[key]);\n  }\n  maxEvents2 = records2.reduce((max, record) => Math.max(max, record.events.length), 0);\n\n  points1.push({\n    x: width / 4,\n    y: height / 2,\n    dir: 0,\n    level: 0,\n    category: null,\n    eventFactor: 1\n  });\n\n  points2.push({\n    x: 3 * width / 4,\n    y: height / 2,\n    dir: 0,\n    level: 0,\n    category: null,\n    eventFactor: 1\n  });\n\n  const maxRecords = Math.max(records1.length, records2.length);\n  // might have to scale depending on the number of records\n  config.maxTrials = maxRecords*70/100;\n  config.n = maxRecords*80/100;\n  // random seed, but it does not work when test and prod files are the same. That is \n  // because the prod data starts with a different position in the random sequence than if it \n  // was running alone.\n  randomSeed(19971008);\n}\n\nfunction draw() {\n  if (points1.length < config.n) {\n    generateNextPoint(1);\n  }\n  if (points2.length < config.n) {\n    generateNextPoint(2);\n  }\n  fill('#FFFFFF');\n  noStroke();\n  for (let shape of shapes1) {\n    push();\n    translate(shape.x, shape.y);\n    rotate(shape.rotation);\n    categoryShapes[shape.category](config.shapeSize);\n    pop();\n  }\n  for (let shape of shapes2) {\n    push();\n    translate(shape.x, shape.y);\n    rotate(shape.rotation);\n    categoryShapes[shape.category](config.shapeSize);\n    pop();\n  }\n  if (points1.length >= config.n && points2.length >= config.n) {\n    noLoop();\n  }\n}\n\nfunction generateNextPoint(execIndex) {\n    // do I have more lines than required?\n    const points = execIndex === 1 ? points1 : points2;\n    const shapes = execIndex === 1 ? shapes1 : shapes2;\n    const records = execIndex === 1 ? records1 : records2;\n    const maxEvents = execIndex === 1 ? maxEvents1 : maxEvents2;\n    let currentRecordIndex = execIndex === 1 ? currentRecordIndex1 : currentRecordIndex2;\n    const xOffset = execIndex === 1 ? 0 : width/2;\n    let valid = false;\n    let trial = 0;\n    while (!valid && trial < config.maxTrials) {\n      let randomPoint = random(points);\n      let branch = random() <= config.pBranch;\n      \n      if (branch) {\n        currentRecordIndex = (currentRecordIndex + 1) % records.length;\n        if (execIndex === 1) {\n          currentRecordIndex1 = currentRecordIndex;\n        } else {\n          currentRecordIndex2 = currentRecordIndex;\n        }\n      }\n      let currentRecord = records[currentRecordIndex];\n      // the eventFactor is loosly related to the number of events in the record. Ideally it should make a bigger difference.\n      // maybe there are better equations to use here\n      let eventFactor = branch ? (1 - (currentRecord.events.length / maxEvents) * 0.05) : randomPoint.eventFactor;\n      let r = config.r * (1 + 1 / (branch ? (randomPoint.level + 1) : randomPoint.level)) * eventFactor;\n      let newCategory = branch ? currentRecord.detectorCategory : randomPoint.category;\n      \n      let {xj, yj, alpha} = getNewPosition(randomPoint, r, branch);\n      \n      // x position based on the visualization we're working with\n      xj = constrain(xj, xOffset + 50, xOffset + width/2 - 50);\n      if (isValidPosition(xj, yj, r, points)) {\n        addNewPoint(xj, yj, alpha, randomPoint, newCategory, eventFactor, points);\n        if (newCategory) {\n          tryAddShape(xj, yj, newCategory, shapes);\n        }\n        valid = true;\n      }\n      trial++;\n    }\n}\n\nfunction getNewPosition(randomPoint, r, branch) {\n    let branchAngle = branch ? (random() < 0.5 ? -PI/2 : PI/2) : 0;\n    let alpha = randomPoint.dir + random(-config.angle, config.angle) + (branch * branchAngle);\n    let xj = randomPoint.x + cos(alpha) * r * width/140;\n    let yj = randomPoint.y + sin(alpha) * r * height/80;\n    return {xj, yj, alpha};\n}\n  \nfunction isValidPosition(x, y, r, points) {\n    // points should stay within their respective areas\n    let halfIndex = x > width/2 ? 2 : 1;\n    let minX = halfIndex === 1 ? 0 : width/2;\n    let maxX = halfIndex === 1 ? width/2 : width;\n    // canvas\n    if (x < minX || x > maxX || y < 0 || y > height) return false;\n    // points and their gaps\n    let minDist = r * width/140;\n    for (let point of points) {\n        if (dist(x, y, point.x, point.y) < minDist) return false;\n    }\n    return true;\n}\n  \nfunction isValidShapePosition(x, y, shapes) {\n    for (let shape of shapes) {\n        if (dist(x, y, shape.x, shape.y) < config.minShapeDistance) {\n            return false;\n        }\n    }\n    let padding = config.shapeSize;\n    // the half we are in\n    let halfIndex = x > width/2 ? 2 : 1;\n    let minX = halfIndex === 1 ? padding : width/2 + padding;\n    let maxX = halfIndex === 1 ? width/2 - padding : width - padding;\n    return x >= minX && x <= maxX && \n            y >= padding && y <= height - padding;\n}\n  \nfunction tryAddShape(x, y, category, shapes) {\n    if (isValidShapePosition(x, y, shapes)) {\n        shapes.push({\n            x: x,\n            y: y,\n            rotation: random(TWO_PI),\n            category: category\n        });\n        return true;\n    }\n    return false;\n}\n  \nfunction addNewPoint(x, y, alpha, randomPoint, category, eventFactor, points) {\n    let newLevel = random() <= config.pBranch ? randomPoint.level + 1 : Math.max(1, randomPoint.level);\n    // had edges here. but thought it is better without them. But they can be added back if needed.\n    points.push({\n      x: x,\n      y: y,\n      dir: alpha,\n      level: newLevel,\n      category: category,\n      eventFactor: eventFactor\n    });\n}\n\nfunction drawTriangle(size) {\n    beginShape();\n    vertex(0, -size);\n    vertex(-size * cos(PI/6), size * sin(PI/6));\n    vertex(size * cos(PI/6), size * sin(PI/6));\n    endShape(CLOSE);\n}\n\nfunction drawSquare(size) {\n    rect(-size/2, -size/2, size, size);\n}\n\nfunction drawRegularShape(sides, size) {\n    beginShape();\n    for (let i = 0; i < sides; i++) {\n      const angle = TWO_PI * i / sides - PI/2;\n      vertex(cos(angle) * size, sin(angle) * size);\n    }\n    endShape(CLOSE);\n}\n\nfunction drawPentagon(size) {\n    drawRegularShape(5, size);\n}\n\nfunction drawHexagon(size) {\n    drawRegularShape(6, size);\n}\n"
    }



  },
  {
    "id": "A11",
    "title": "Unknown",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "None",
    "classification":{
      "material_and_processes": ["synthesized_image","randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual","static"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"plein014-core",
      "extension":".js",
      "content":"var xoff = 0.0\nvar xinc = 42\n\nfunction hal() {\n    let resx, resy, stepx, stepy, x, y, x1, y1, coords, p1, p2, p3, p4\n    resx = 2 * Math.floor(random(2, 5)); resy = 2 * Math.floor(random(2, 5)); coords = []\n    stepx = Math.floor(actualwidth / resx); stepy = Math.floor(actualheight / resy)\n    x = leftmargin\n    for (let i = 0; i < resx; i++) {\n        y = topmargin\n        for (let j = 0; j < resy; j++) {\n            x1 = x + stepx * noise(xoff); xoff += xinc; y1 = y + stepy * noise(xoff)\n            coords.push({ x: x1, y: y1 })\n            y += stepy}\n        x += stepx}\n    for (let i = 0; i < resx - 1; i++) {\n        for (let j = 0; j < resy - 1; j++) {\n            p1 = coords[i * resy + j]; p2 = coords[i * resy + j + resy]; p3 = coords[i * resy + j + resy + 1]; p4 = coords[i * resy + j + 1]\n            trianglewlines(p1.x, p1.y, p2.x, p2.y, p4.x, p4.y);\n            trianglewlines(p2.x, p2.y, p3.x, p3.y, p4.x, p4.y);\n}}}\n\nfunction trianglewlines(x1, y1, x2, y2, x3, y3) {\n    // https://mathopenref.com/coordincenter.html\n    len1 = dist(x2, y2, x3, y3); len2 = dist(x1, y1, x3, y3); len3 = dist(x1, y1, x2, y2)\n    cx = (len1 * x1 + len2 * x2 + len3 * x3) / (len1 + len2 + len3); cy = (len1 * y1 + len2 * y2 + len3 * y3) / (len1 + len2 + len3)\n    for (let i = 0; i < 1; i += 0.03) {\n        triangle(lerp(cx, x1, i), lerp(cy, y1, i), lerp(cx, x2, i), lerp(cy, y2, i), lerp(cx, x3, i), lerp(cy, y3, i),\n)}}"
    }



  },
  {
    "id": "A12",
    "title": "viduru",
    "artist": "Unknown",
    "year": "2020",
    "repoUrl": "None",
    "classification":{
      "material_and_processes": ["synthesized_image", "synthesized_sound", "randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "auditory", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"viduru",
      "extension":".js",
      "content":"let voronoi;\nlet diagram;\nlet points = [];\nlet centerX, centerY;\nlet bounds;\nlet expansionRate = 1;\nlet maxPoints = 500;\nlet delay = 30;\nlet lastUpdated = 0;\nlet cellColors = {};\nlet isRunning = false;\nlet startButton;\n\nlet osc;\nlet notes = [\n  523.25, // C5\n  587.33, // D5\n  659.25, // E5\n  698.46, // F5\n  783.99, // G5\n  880.00, // A5\n  987.77, // B5\n  1046.50 // C6\n];\n\nfunction setup() {\n  createCanvas(800, 800);\n  colorMode(HSB, 360, 100, 100, 100);\n  centerX = width / 2;\n  centerY = height / 2;\n  voronoi = new Voronoi();\n  bounds = {xl: 0, xr: width, yt: 0, yb: height}; \n  startButton = createButton('Start');\n  startButton.position(width/2 - 50, height/2);\n  startButton.mousePressed(startAudio);\n  osc = new p5.Oscillator('sine');\n}\n\nfunction startAudio() {\n  if (!isRunning) {\n    getAudioContext().resume().then(() => {\n      osc.start();\n      osc.amp(0);\n      initializeVoronoi();\n      startButton.style('display', 'none');\n      isRunning = true;\n    });\n  }\n}\n\nfunction playNote() {\n  let note = random(notes);\n  osc.freq(note);\n  osc.amp(0.2, 0);\n  osc.amp(0, 0.1);\n}\n\nfunction draw() {\n  background(255);\n  if (isRunning) {\n    drawVoronoi();\n    controlVoronoi();\n  }\n}\n\nfunction initializeVoronoi() {\n  points = [{x: centerX, y: centerY}];\n  diagram = voronoi.compute(points, bounds);\n  assignCellColors();\n}\n\nfunction drawVoronoi() {\n  if (diagram) {\n    for (let cell of diagram.cells) {\n      let color = cellColors[cell.site.x + \",\" + cell.site.y];\n      fill(color.hue, color.saturation, color.brightness, color.alpha);\n      stroke(255, 30);\n      strokeWeight(1);\n      beginShape();\n      for (let halfedge of cell.halfedges) {\n        let glitch = random(0, 1);\n        let startPoint = halfedge.getStartpoint();\n        if (glitch < 0.995) {\n          vertex(startPoint.x, startPoint.y);\n        }\n      }\n      endShape(CLOSE);\n    }\n  }\n}\n\nfunction controlVoronoi() {\n  if (frameCount - lastUpdated >= delay && points.length < maxPoints) {\n    expandVoronoi();\n    lastUpdated = frameCount;\n  }\n}\n\nfunction expandVoronoi() {\n  let newPoints = [];\n  for (let i = 0; i < expansionRate; i++) {\n    if (points.length < maxPoints) {\n      let angle = random(TWO_PI);\n      let radius = random(points.length) * 2;\n      let x = centerX + cos(angle) * radius;\n      let y = centerY + sin(angle) * radius;\n      newPoints.push({x, y});\n      playNote();\n    }\n  }\n  points = points.concat(newPoints);\n  diagram = voronoi.compute(points, bounds);\n  assignCellColors();\n}\n\nfunction assignCellColors() {\n  for (let cell of diagram.cells) {\n    if (!(cell.site.x in cellColors)) {\n      let bw = random() < 0.75 ? 0 : 100;\n      cellColors[cell.site.x + \",\" + cell.site.y] = {\n        hue: 0,\n        saturation: 0,\n        brightness: bw,\n        alpha: 100\n      };\n    }\n  }\n}\n"
    }


  },
  {
    "id": "A13",
    "title": "8M_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["processed_audio","processed_image","synthesized_image","synthesized_text","randomness","interactions"], 
      "interaction": ["human_interaction", "computer_interaction"], 
      "outcome": ["visual","auditory","time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"8M_sketch",
      "extension":".js",
      "content":"var soundFile;\nlet flowerPositions = [];\nlet flowerScale = [];\nlet redFlowerPositions = [];\nlet redFlowerScale = [];\n\nlet nombres = [\"Ariana Maritza Bravo Aracena\", \"Bartolita del Carmen Paredes Castillo\", \"Pamela VerÃ³nica Fonseca Rebolledo\", \"Brenda Cartes GuzmÃ¡n\", \"Mariana Ariela Milla NuÃ±ez\", \"Yorka Gonzalez Barrera\", \"Herlin MontaÃ±o Valencia\", \"EstefanÃ­aÂ ConstanzaÂ BreveÂ Neira\", \"Kimberly Ugalde Palma\", \"Damaris Ana MeliÃ±ir Llanqui\", \"Norma Jeannette Quiroga ZÃºÃ±iga\", \"Valeria Esmeralda Ortiz OyarzÃºn\", \"Carolina Ortega Cariqueo\", \"Michelle\", \"Valentina\", \"Carmen Rosa GonzÃ¡lez ValdÃ©s\", \"Rosa NÃ©lida MuÃ±oz Antonapai\", \"Franshesca Tamara GonzÃ¡lez Miranda\", \"MarÃ­a Teresa SepÃºlveda Smith\", \"Stephanie Emilien\", \"Rosa Francisca Millanao Chule\", \"Paulina Alejandra Gatica GonzÃ¡lez\", \"Maylin Rachel Guevara Guevara\", \"Catalina\", \"Jocelyn\", \"Laura Norma Maldonado SolÃ­s\", \"Yaritza Navarro GonzÃ¡lez\", \"Gloria Yanet LabraÃ±a Aros\", \"Willianyis Rojas Rosales\", \"A.C.Contreras V.\", \"VerÃ³nica del Carmen Palacios Tapia\", \"MarÃ­a de JesÃºs BermÃºdez Fuentes\", \"MarÃ­a Amparo VelÃ¡squez GarcÃ©s\", \"MÃ³nica Astorga Vega\", \"JÃ©ssica del Carmen GonzÃ¡lez Toledo\", \"Jessica Angelina Ortiz Cisternas\", \"VerÃ³nica Cuero Cuero\", \"Madely Padilla MartÃ­nez\", \"Marjorie Caris Aillal \", \"Olga del TrÃ¡nsito Poblete Campos\", \"Jeanette de las Mercedes Sepulveda CurÃ­n\", \"Pamela Solange Ãlvarez Soto\", \"Rosa Fritis Barraza\", \"Gabriela Machicado Hurtado\"]\n\n\nlet cloudPositions = [[-70 , -150 , 140], [-1000 , -150 , 70], [-100 , -100 , 100], [-70 , 70 , 70]];\nvar x = 0;\nvar y = 0;\n\nvar n_a_femicides = 163;\nvar n_femicides = 44;\n\nlet inconsolata;\n\n\nfunction preload() {\n  flower = loadModel(\"assets/12973_anemone_flower_v1_l2.obj\");\n  grass = loadModel(\"assets/10450_Rectangular_Grass_Patch_v1_iterations-2.obj\");\n  \n  cloud = loadModel(\"assets/Cloud model.obj\");\n\n  flowerImg = loadImage(\"assets/12973_anemone_flower_diff.jpg\");\n  redFlowerImg = loadImage(\"assets/redFlower-1.jpg\");\n  grassImg = loadImage(\"assets/10450_Rectangular_Grass_Patch_v1_Diffuse.jpg\");\n\n  soundFile = loadSound(\"assets/clairdelune.mp3\");\n  inconsolata = loadFont('assets/Inconsolata.otf');\n  \n}\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight, WEBGL);\n\n  amplitude = new p5.Amplitude();\n  soundFile.play();\n\n  amplitude.setInput(soundFile);\n  amplitude.smooth(0.9);\n\n  fft = new p5.FFT();\n\n  peakDetect = new p5.PeakDetect(20, 400, 0.2);\n  normalMaterial();\n  \n  textFont(inconsolata);\n  textSize(width / 40);\n  textAlign(CENTER, CENTER);\n  \n  y = -width\n  for (i = 0; i < 5; i++){\n    cloudPositions.push([random(-1000, 100), random(-1000, 100), random(50, 200)])\n  }\n  \n  \n  noCursor()\n}\n\nfunction draw() {\n  background(0, 100, 255);\n  //normalMaterial()\n  noStroke();\n  x++;\n  y += 0.2;\n  \n  if (y > width){\n    y = -width\n  }\n\n  orbitControl(0.5, 0.5, 0.5);\n\n  ambientLight(100);\n\n  let dirX = mouseX / width - 0.5;\n  let dirY = mouseY / height - 0.5;\n  directionalLight(250, 250, 250, -dirX, -dirY, -1);\n\n  let locX = mouseX - width / 2;\n  let locY = mouseY - height / 2;\n\n  pointLight(250, 250, 250, locX, locY, 50);\n\n  let spectrum = fft.analyze();\n\n  fft.analyze();\n  peakDetect.update(fft);\n\n  if (peakDetect.isDetected) {\n    if (n_a_femicides > 0) {\n      //console.log(\"red\");\n      redFlowerPositions.push([random(-150, 150), random(-140, 220), -40]);\n      redFlowerScale.push(random(0.5, 2));\n\n      n_a_femicides -= 1;\n    } else if (n_femicides > 0) {\n      //console.log(\"white\");\n      flowerPositions.push([random(-150, 150), random(-140, 220), -40]);\n      flowerScale.push(random(1.5, 2.5));\n      n_femicides -= 1;\n    } \n  }\n  \n  if (n_femicides == 0 && n_a_femicides == 0){\n    push()\n    translate(0, 200, 0)\n    text(\"In 2021, there were 163 attempted femicides and 44 consumed femicides in Chile. NO ESTAMOS TODAS.\",  -width/2, 0, width)\n    pop()\n    for (let i = 0; i < flowerPositions.length; i++){\n      push()\n      translate(0, -200, 100)\n      translate(flowerPositions[i][0],\n      flowerPositions[i][1],\n      flowerPositions[i][2])\n      textSize(width / 100);\n      text(nombres[i], 0, 0)\n      pop()\n    }\n  }\n\n  push();\n  translate(0, 0, -100);\n  rotateX(PI / 3);\n  scale(1.5);\n  //plane(400);\n  texture(grassImg);\n  textureMode(NORMAL);\n  model(grass);\n  pop();\n\n  for (let i = 0; i < flowerPositions.length; i++) {\n    push();\n    rotateX(PI / 3);\n    rotateZ(PI);\n    texture(flowerImg);\n    textureMode(NORMAL);\n    translate(\n      flowerPositions[i][0],\n      flowerPositions[i][1],\n      flowerPositions[i][2]\n    );\n    scale(flowerScale[i]);\n    //rotateZ(PI)\n    model(flower);\n\n    pop();\n  }\n\n  for (let i = 0; i < redFlowerPositions.length; i++) {\n    push();\n    rotateX(PI / 3);\n    rotateZ(PI);\n    texture(redFlowerImg);\n    textureMode(NORMAL);\n    translate(\n      redFlowerPositions[i][0],\n      redFlowerPositions[i][1],\n      redFlowerPositions[i][2]\n    );\n    scale(redFlowerScale[i]);\n    //rotateZ(PI)\n    model(flower);\n\n    pop();\n  }\n\n  push();\n  translate(-width / 2, -height / 2, 0);\n  shininess(300);\n  fill(255, 255, 0);\n  translate(mouseX, mouseY, 50);\n  sphere(20);\n  pop();\n\n  shininess(200);\n\n  fill(0, 255, 0);\n  \n  for (let i = 0; i < cloudPositions.length; i ++){\n    push()\n      rotateX(PI/3)\n      rotateZ(PI/3)\n      fill(255, 255, 255, 100)\n      translate( cloudPositions[i][0], cloudPositions[i][1]+ y, cloudPositions[i][2])\n\n      model(cloud);\n    pop()\n  }\n \n}\n"
    }



  },
  {
    "id": "A14",
    "title": "Crazy_Christmas_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["processed_image","synthesized_image"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Crazy_Christmas_sketch",
      "extension":".js",
      "content":"function preload() {\n  tree = loadModel('Lowpoly_tree_sample.obj');\n  tree2 = loadModel('lowpolytree.obj');\n  treeImg = loadImage('green-color-leaves-pattern-free-vector.png');\n}\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight, WEBGL);\n  stroke(100)\n  video = createCapture(VIDEO);\n  video.size(windowWidth, windowHeight);\n  video.hide()\n}\n\nfunction draw() {\n  if (!mouseIsPressed){\n    background(0);\n  }\n  //background(0);\n  //translate(-width/3, -height/2, 0);\n  /*\n  push()\n  translate(-10, 10, 0);\n  let dirX = (mouseX / width - 0.5) * 2;\n  let dirY = (mouseY / height - 0.5) * 2;\n  directionalLight(250, 250, 250, -dirX, -dirY, -1);\n  for (let i = 0; i<10; i++){\n    translate(10, -10, 0);\n    \n    normalMaterial();\n    push();\n    //rotateZ(frameCount * 0.01);\n    //rotateX(frameCount * 0.01);\n    rotateY(frameCount * 0.01);\n    for (let i = 0; i<10; i++){\n    translate(0, 10, 0);\n    \n    normalMaterial();\n    push();\n    //rotateZ(frameCount * 0.01);\n    //rotateX(frameCount * 0.01);\n    rotateY(frameCount * 0.01);\n    \n    //rotateY(map(mouseX, 0, width, PI/2, -PI/2))\n    torus(30, 10);\n  }\n    \n    //rotateY(map(mouseX, 0, width, PI/2, -PI/2))\n    torus(40, 10);\n  }\n  pop()*/\n  \n  //translate(-10, 10, 0);\n  let dirX = (mouseX / width - 0.5) * 2;\n  let dirY = (mouseY / height - 0.5) * 2;\n  directionalLight(250, 250, 250, -dirX, -dirY, -1);\n  let locX = mouseX - width / 2;\n  let locY = mouseY - height / 2;\n  \n  pointLight(250, 250, 250, locX, locY, 50);\n  shininess(10);\n  \n  push()\n  normalMaterial();\n  \n  /*\n  push()\n     for (let i = 0; i<10; i++){\n       translate(0, 10, 10)\n       rotateY(frameCount * 0.01);\n       cone(20, 40);\n     }\n  pop()*/\n  \n  texture(treeImg);\n  textureMode(NORMAL);\n  for (let i = 0; i<30; i++){\n    \n    \n    //normalMaterial();\n    push();\n    rotateZ(frameCount * 0.01);\n    //rotateX(frameCount * 0.01);\n    rotateY(frameCount * 0.01);\n    for (let i = 0; i<10; i++){\n      translate(0, 10, 0);\n\n      //normalMaterial();\n      push();\n      //rotateZ(frameCount * 0.01);\n      //rotateX(frameCount * 0.01);\n      rotateY(frameCount * 0.01);\n\n      //rotateY(map(mouseX, 0, width, PI/2, -PI/2))\n      //scale(1.1); \n      model(tree);\n      \n      push()\n        translate(20, 20, 20)\n        sphere(5)\n      pop()\n\n\n    }\n    push()\n\n      for (let j = 0; j<7; j++){\n\n        normalMaterial();\n        scale(1.5)\n        translate(0, 10, 0);\n        rotateX(frameCount * 0.01);\n        model(tree2)\n        scale(1)\n      }\n    pop()\n    scale(1)\n    //rotateY(map(mouseX, 0, width, PI/2, -PI/2))\n    model(tree);\n\n    texture(video);\n    textureMode(NORMAL);\n    sphere(30)\n\n    texture(treeImg);\n  textureMode(NORMAL);\n    push()\n    for (let i = 0; i<5; i++){\n      specularMaterial(250);\n        rotateX(frameCount * 0.05);\n      rotateY(frameCount * 0.02);\n      rotateZ(frameCount * 0.01);\n        translate(20, 20, 20)\n        sphere(5)\n    }\n    pop()\n  }\n  pop()\n  \n  \n  \n  \n}"
    }



  },
  {
    "id": "A15",
    "title": "CreativityAssignment_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["synthesized_image","synthesized_text","randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "static"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"CreativityAssignment_sketch",
      "extension":".js",
      "content":"\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  background(0)\n  textSize(width / 8);\n  textAlign(CENTER, CENTER);\n  \n  const randomWidth = random(windowWidth)\n  const randomHeight = random(windowHeight)\n\n\n  noFill();\n  \n  strokeWeight(2)\n  \n  \n  for(let i=0; i<25; i++){\n    strokeWeight(i/4)\n    stroke(255-(20*i), 0, 250);\n    bezier(0, 0, randomHeight*i, 10+i, 90+i, 90+i, 0, windowHeight);\n    stroke(0, 255-(10*i), 200);\n    bezier(0, 0, randomWidth*i, randomHeight*i, 120+10*i, 10*i, windowWidth, 0);\n    stroke(255-(20*i), i*20,0);\n    bezier(0, windowHeight, randomHeight*i, i, 120+i, 10+i, windowWidth, windowHeight);\n  }\n  \n  fill(255)\n  stroke(0)\n  strokeWeight(0)\n  text('Creativity', windowWidth/2, windowHeight/2);\n  \n  noFill();\n  \n  strokeWeight(1)\n  for(let i=0; i<25; i++){\n    stroke(100, i*20,100);\n    strokeWeight(i/4)\n    bezier(windowWidth, 0, randomWidth*i, i, randomHeight+i, 10+i, windowWidth, windowHeight);\n  }\n  \n}\n\nfunction piramids(bottom, top){\n  for(let i=0; i<windowHeight+1000; i+=30){\n    fill(255, 255, 0, 200)\n    triangle(i, bottom*windowHeight/10, i, top*windowHeight/10, 81+i, bottom*windowHeight/10);\n\n    fill(255, 0, 255, 200)\n    triangle(i, bottom*windowHeight/10, i+30, top*windowHeight/10, 81+i, bottom*windowHeight/10);\n  }\n}\n\nfunction inversePiramids(bottom, top){\n  for(let i=0; i<windowHeight+1000; i+=30){\n    fill(255, 0, 255, 200)\n    triangle(i, bottom*windowHeight/10, i, top*windowHeight/10, 81+i, bottom*windowHeight/10);\n\n    fill(255, 255, 0, 200)\n    triangle(i, bottom*windowHeight/10, i+30, top*windowHeight/10, 81+i, bottom*windowHeight/10);\n  }\n}\n\n\nfunction draw() {\n  \n  \n  strokeWeight(0)\n  inversePiramids(0,1)\n  \n  piramids(10,9)\n  \n  fill(0)\n  stroke(0)\n  strokeWeight(0)\n  \n  textSize(width / 20);\n  text('what is', 1*windowWidth/10, 0.5*windowHeight/10);\n  \n  fill(0,255,255)\n  text('what is', 1.03*windowWidth/10, 0.53*windowHeight/10);\n  \n  \n  textSize(width / 8);\n  \n  \n}"
    }



  },
  {
    "id": "A16",
    "title": "Dreams_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["synthesized_image","randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Dreams_sketch",
      "extension":".js",
      "content":"let angle = 0;\nlet angle2 = 0;\nlet speed = 0.001;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n\n  noFill();\n}\n\nfunction draw() {\n  let speed = map(mouseY, 0, height, -0.2, 0.2);\n  let arm = map(mouseX, 0, width, 10, 300);\n  let color = map(arm, 10, 400, 0, 300);\n  let color2 = map(angle, 0, TWO_PI, 0, 300);\n\n  background(255);\n  translate(width / 2, height / 2);\n  pinWheel(arm, color, color2, angle, true);\n\n  for (let i = 0; i < 10; i++) {\n    push();\n    rotate((i * TWO_PI) / 10);\n    translate(0, 2 * arm);\n    pinWheel(arm / 2, 255, 255, -2 * angle, true);\n\n    pop();\n  }\n}\n\nfunction pinWheel(arm, color, color2, rotateSpeed, hasCircles) {\n  rotate(rotateSpeed);\n  let shearValue = map(mouseY, 0, height, 1, 10);\n\n  for (let i = 0; i < 10; i++) {\n    push();\n    if (mouseIsPressed) {\n      shearX((i * TWO_PI) / shearValue);\n      shearY((i * TWO_PI) / shearValue);\n    }\n    //shearX((i * TWO_PI) / shearValue)\n    rotate((i * TWO_PI) / 10);\n    translate(0, arm);\n    circle(0, 0, 10);\n    line(0, 0, arm, arm / 2);\n\n    line(0, 0, arm / 2, arm);\n\n    strokeWeight(3);\n    stroke(0, 0, 255);\n    line(-40, -40, arm / 2, angle);\n    stroke(0);\n    //triangle(-15,20, 40, 10, 100, 20)\n    fill(color, 0, 255, 40);\n    triangle(-15, arm / 2, arm, 10, 40, 20);\n\n    triangle(-15, -arm / 2, arm, 10, 40, 20);\n    strokeWeight(0);\n    fill(0, 255, color, 150);\n    triangle(0, -arm, -200, 10, arm / 5, 10);\n    noFill();\n    fill(255, 0, color, 150);\n    triangle(0, -arm, -arm / 2, 10, 200, 50);\n    noFill();\n    strokeWeight(1);\n    stroke(0);\n    line(-15, -arm, arm, 100);\n\n    stroke(255, arm, 0);\n    strokeWeight(arm / 50);\n    line(-15, -arm, arm, 200);\n    strokeWeight(1);\n    stroke(0);\n\n    if (hasCircles) {\n      rotate(angle2 / 2);\n      circles(angle2, arm, speed);\n      angle2 += speed;\n    }\n\n    pop();\n  }\n\n  angle += speed / 2;\n}\n\nfunction circles(angle2, arm, speed) {\n  for (let j = 0; j < 3; j++) {\n    push();\n    rotate((j * TWO_PI) / 5);\n    translate(0, arm);\n    fill(255, 255, 0, 150);\n    circle(0, 0, arm / 8);\n    noFill();\n    pop();\n  }\n}\n"
    }



  },
  {
    "id": "A17",
    "title": "Elqui_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["synthesized_image","randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Elqui_sketch",
      "extension":".js",
      "content":"let starPoints = 1;\nlet desertColor = '#FFFFFF';\nlet radiusOne = 2;\nlet radiusTwo = 2;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  background(220)\n  \n}\n\n\n// STAR FUNCTION: from the p5 references\nfunction star(x, y, radius1, radius2, npoints) {\n  let angle = TWO_PI / npoints;\n  let halfAngle = angle / 2.0;\n  beginShape();\n  for (let a = 0; a < TWO_PI; a += angle) {\n    let sx = x + cos(a) * radius2;\n    let sy = y + sin(a) * radius2;\n    vertex(sx, sy);\n    sx = x + cos(a + halfAngle) * radius1;\n    sy = y + sin(a + halfAngle) * radius1;\n    vertex(sx, sy);\n  }\n  endShape(CLOSE);\n}\n\n\nfunction draw() {\n  //fences()\n  \n fill(desertColor)\n  if (mouseIsPressed){\n    star(mouseX, mouseY, radiusOne, radiusTwo, starPoints)\n  }\n\n  \n  if(keyIsDown(RIGHT_ARROW)){\n    starPoints += 1;\n  }else if (keyIsDown(LEFT_ARROW) && starPoints>1) {\n    starPoints -= 1;\n  }else if (keyIsDown(65)&& radiusOne>1){\n    console.log(\"Se apreta tecla\")\n    radiusOne -= 1\n  }\n  else if (keyIsDown(83)&& radiusOne>=1){\n    console.log(\"Se apreta tecla\")\n    radiusOne += 1\n  }\n  else if (keyIsDown(81)&& radiusTwo>1){\n    console.log(\"Se apreta tecla\")\n    radiusTwo -= 1\n  }\n  else if (keyIsDown(87)&& radiusTwo>=1){\n    console.log(\"Se apreta tecla\")\n    radiusTwo += 1\n  }\n  \n}\n\nfunction keyPressed() {\n  switch (keyCode){\n    case 49:\n      desertColor = '#63474D';\n      break;\n    case 50:\n      desertColor = '#AA767C';\n      break;\n    case 51:\n      desertColor = '#D6A184';\n      break;\n    case 52:\n      desertColor = '#FFA686';\n      break;\n    case 53:\n      desertColor = '#FEC196';\n      break;\n    case 0:\n      desertColor = '#FFFFFF';\n  }\n\n}\n"
    }



  },
  {
    "id": "A18",
    "title": "Final_Sound_Project_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["processed_audio","synthesized_image","randomness","interactions"], 
      "interaction": ["human_interaction","computer_interaction"], 
      "outcome": ["visual", "auditory", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Final_Sound_Project_sketch",
      "extension":".js",
      "content":"//songs\n//Get It - Keshi\n//The Search - NF\n//Pure Sky - Genshin Impact\n\n//Code inspired by therewasaguy and FilipaRita and a lot of p5.js references\n\nlet song;\nlet song2;\nlet song3;\nlet fft;\nvar button;\nvar button1;\nvar button2;\n\nlet w, a, d, r, g, b, x;\n\nlet dt = 0.1;\nlet degree = 0;\nvar smoothing = 0.8; // play with this, between 0 and .99\nvar binCount = 1024; // size of resulting FFT array. Must be a power of 2 between 16 an 1024\nvar particles =  new Array(binCount);\n\nlet slider;\n\nfunction preload() {\n  song1 = loadSound(\"NF.mp3\");\n  song2 = loadSound(\"keshi.mp3\");\n  song3 = loadSound(\"Sky.mp3\");\n  button = createButton('Song2');\n  button.position(windowWidth/2 - 20, windowHeight - 100);\n  button.mousePressed(toggleNext1);\n  \n  button1 = createButton(\"Song3\");\n  button1.position(windowWidth/2 + 80, windowHeight - 100);\n  button1.mousePressed(toggleNext);\n  \n  button2 = createButton(\"Song1\");\n  button2.position(windowWidth/2 - 120, windowHeight - 100);\n  button2.mousePressed(toggleNext2);\n}\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n\n\n  fft = new p5.FFT(smoothing, binCount);\n  fft = new p5.FFT();\n  for (var i = 0; i < particles.length; i++) {\n  var x = map(i, 0, binCount, 0, width * 2);\n  var y = random(0, height);\n  var position = createVector(x, y);\n  particles[i] = new Particle(position);\n  }\n  \n  slider = createSlider(0, 1, 0.1, 0.1);\n  slider.position(windowWidth - 150, windowHeight - 100);\n  slider.style('width', '80px');\n  \n}\n\nfunction draw() {\n  background(0);\n  \n  //noFill();\n  noStroke();\n  background(0, 0, 0, 100);\n\n  var spectrum = fft.analyze(binCount);\n\n  for (var i = 0; i < binCount; i++) {\n    var thisLevel = map(spectrum[i], 0, 255, 0, 1);\n\n    // update values based on amplitude at this part of the frequency spectrum\n    particles[i].update( thisLevel );\n\n    // draw the particle\n    particles[i].draw();\n\n    // update x position (in case we change the bin count while live coding)\n    particles[i].position.x = map(i, 0, binCount, 0, width * 2);\n    \n    \n  }\n  \n  \n  \n  \n  //stroke(255, 230);\n  //stroke(221, 160, 221);\n  //stroke(255, 0, 0);\n  stroke(a, w, d);\n  //noFill();\n  //lines\n  //noStroke();\n  strokeWeight(4);\n\n  translate(width / 2, height / 2);\n  angleMode(DEGREES);\n\n  //fill(0, 191, 255);\n  fill(r, g, b);\n  let circle = fft.waveform();\n  \n  for (let t = -1; t <= 1; t += 2) {\n    \n    beginShape();\n\n    for (let i = 0; i <= 180; i += 0.1) {\n      let index = floor(map(i, 0, 180, 0, circle.length));\n\n      let r = map(circle[index], -1, 1, -5, 150);\n      let x = r * sin(i) * t;\n      let y = r * cos(i);\n      vertex(x, y);\n    }\n    endShape();\n  }\n  \n  let val = slider.value();\n  song1.setVolume(slider.value());\n  song2.setVolume(slider.value());\n  song3.setVolume(slider.value());\n}\n\n\n\nvar Particle = function(position) {\n  this.position = position;\n  this.scale = random(0, 0.1);\n  this.speed = createVector(0, random(0, 10) );\n  //this.color = [random(0, 255), random(0,255), random(0,255)];\n  this.color = [random(0, 80),random(0, 255), random(200, 255)];\n  //this.color = [random(a, r), random(w, g), random(d, b)];\n  //this.color = [255];\n  // function toggleNext() {\n  //   this.color = [255];\n  // }\n\n}\n\nvar theyExpand = 1;\n\n// use FFT bin level to change speed and diameter\nParticle.prototype.update = function(someLevel) {\n  this.position.y += this.speed.y / (someLevel*2);\n  if (this.position.y > height) {\n    this.position.y = 0;\n  }\n  this.diameter = map(someLevel, 0, 1, 0, 100) * this.scale * theyExpand;\n\n}\n\n\nParticle.prototype.draw = function() {\n  fill(this.color);\n  ellipse(\n    this.position.x, this.position.y,\n    this.diameter, this.diameter\n  );\n}\n\n//color\nfunction mousePressed() {\n  // Check if mouse is inside the circle\n  let d = dist(mouseX, mouseY, windowWidth/2, windowHeight/2);\n  if (d < 100) {\n    // Pick new random color values\n    r = random(255);\n    g = random(255);\n    b = random(255);\n    x = 255;\n  }\n}\n\n\nfunction toggleNext1() {\n  //let d = dist(mouseX, mouseY, windowWidth/2 - 20, windowHeight - 100 )\n  //if (d < 50) {\n      a = 255;\n      r = 128;\n      w = 0;\n      g = 0;\n      d = 0;\n      b = 128;\n    if (song1.isPlaying()) {\n      song1.pause();\n      button.html(\"Song2\")\n\n      \n    }\n    else {\n      song1.play();\n      button.html(\"Pause\")\n    }\n    //}\n}\n\nfunction toggleNext() {\n  r = 0;\n  g = 191;\n  b = 255;\n  \n  a = 230;\n  w = 230;\n  d = 250;\n  if(song3.isPlaying()) {\n    song3.pause();\n    button1.html(\"Song3\");\n  }\n  else {\n    song3.play();\n    button1.html(\"Pause\")\n  }\n}\n\nfunction toggleNext2() {\n  r = 255;\n  g = 255;\n  b = 224;\n  \n  a = 106;\n  w = 90;\n  d = 205;\n  \n  if (song2.isPlaying()) {\n    song2.pause();\n    button2.html(\"Song1\");\n  }\n  else {\n    song2.play();\n    button2.html(\"Pause\");\n  }\n    \n}\n"
    }



  },
  {
    "id": "A19",
    "title": "Nicanor_Parra_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["processed_text","synthesized_image","synthesized_text"], 
      "interaction": ["human_interaction", "computer_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Nicanor_Parra_sketch",
      "extension":".js",
      "content":"let lines\nlet spacewidth = 6\nlet wordHeight = 20\n\nfunction preload() {\n  poem1 = loadStrings('cronos.txt') \n  poem2 = loadStrings('poesiaMorira.txt')\n  poem3 = loadStrings('test.txt')\n  \n  lines = random([poem1, poem2, poem3])\n  \n}\n\nfunction setup() {\n  createCanvas(600, 800)\n  //noLoop()\n  fontsToChoose = random(['Anton', 'Shizuru', 'Cinzel'])\n  textFont(fontsToChoose);\n}\n\nfunction draw() {\n  \n  background(50)\n  textSize(wordHeight)\n  fill(255)\n  //textAlign(LEFT, TOP)\n  \n  for (let i = 0; i < lines.length; i ++ ) {\n    let prevMod = 0\n    var doc = window.nlp(lines[i])\n    let textToPrint = doc\n\n    \n    let words = lines[i].split(\" \")\n    /* if (lines[0] == \"QuÃ© es un antipoeta:\"){\n      //text(words[j], 25 + offset, 25 + i * 20)\n      \n      //createCheckbox(lines[i], false);\n    } */\n    // Word by word rendering\n    let offset = 0\n    for (let j = 0; j < words.length; j++) {\n       //prevMod += cos(random()) * 4\n       let wordwidth = textWidth(words[j])\n\n       //fill(128 + 10 * i)\n    \n      \n      \n       \n      if (mouseIsPressed && lines[0] == \"En Santiago de Chile\"){\n      rect(25 + offset, 10 + i * 20, wordwidth, 18)\n        \n      heart(width/2, height/2, height/4)\n    }else if (mouseIsPressed && lines[0] == \"LA\"){\n\n      \n      text(\"âœ\".repeat(words[j].length), 25 + offset, 25 + i * 20)\n      heart(width/2, height/2, height/4)\n    }else if (lines[0] == \"QuÃ© es un antipoeta:\"){\n      text(words[j], 25 + offset, 25 + i * 20)\n      //createCheckbox(words.join(' '), false);\n       \n    }\n      else{\n      text(words[j], 25 + offset, 25 + i * 20)\n    }\n       \n      offset += wordwidth + spacewidth\n     }\n    \n    if (lines[0] == \"QuÃ© es un antipoeta:\" && mouseY <25 + (i) * 20 && mouseY >25 + (i-1) * 20){\n      text( \"â‡¦\", 25 + offset, 25 + i * 20)\n    }\n    \n  }\n}\n\n\n// original heart from https://editor.p5js.org/Mithru/sketches/Hk1N1mMQg\nfunction heart(x, y, size) {\n  noFill()\n  stroke(255)\n  strokeWeight(3)\n  beginShape();\n  vertex(x, y);\n  bezierVertex(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);\n  bezierVertex(x + size, y + size / 3, x + size / 2, y - size / 2, x, y);\n  endShape(CLOSE);\n  \n  \n  ellipse(x -height/15, y + height/15, 30, 55);\n  \n  ellipse(x +height/15, y + height/15, 30, 55);\n  \n  fill(255)\n  ellipse(x +height/16, y + height/13, 15, 25);\n  \n  /*\n  line(x+height/12, y+height/6+10, x+height/12+ 10, y+height/4+30)\n  line(x+height/12+ 10, y+height/4+30, x+height/12+ 30, y+height/4+30)\n  \n  line(x+height/12, y+height/6+10, x+height/12+ 10, y+height/4+30)\n  line(x+height/12+ 10, y+height/4+30, x+height/12+ 30, y+height/4+30)\n  */\n  \n  noStroke()\n  fill(255)\n}\n"
    }



  },
  {
    "id": "A20",
    "title": "Piano_Pedals_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["synthesized_sound","synthesized_image","interactions"], 
      "interaction": ["human_interaction"],
      "outcome": ["visual", "auditory", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Piano_Pedals_sketch",
      "extension":".js",
      "content":"let allOscs = [];\nlet oscType = \"sine\";\nlet oscCount = 5;\nlet upDown = \"none\";\n\nfunction setup() {\n  background(255);\n  noStroke();\n  fill(0);\n  createCanvas(windowWidth, windowHeight);\n  textAlign(CENTER, CENTER);\n}\nfunction draw() {\n  background(0);\n  //text(\"click to create an oscillator\", width/2, height/2);\n  if (frameCount % 30 == 0) {\n    for (let i = 0; i < allOscs.length; i++) {\n      allOscs[i].pan(map(mouseX, 0, width, -1, 1));\n      if (upDown == \"up\") {\n        allOscs[i].freq(allOscs[i].getFreq() + 10, 0.7);\n      } else if (upDown == \"down\") {\n        allOscs[i].freq(allOscs[i].getFreq() - 10, 0.7);\n      }\n      \n    }\n  }\n  for (let i = 0; i < allOscs.length; i++) {\n\n    line(map(allOscs[i].getFreq(), 100, 1200, 0, width), 0, map(allOscs[i].getFreq(), 100, 1200, 0, width), height)\n  }\n  \n}\n\nfunction keyPressed(e) {\n  if (\n    e.key != \"1\" &&\n    e.key != \"2\" &&\n    e.key != \"3\" &&\n    e.key != \"4\" &&\n    e.key != \"6\" &&\n    e.key != \"7\" &&\n    e.key != \"8\"\n  ) {\n    let osc = new p5.Oscillator();\n    osc.setType(oscType);\n    osc.freq(map(keyCode, 65, 90, 100, 1000));\n    stroke(255);\n    line(\n      map(keyCode, 65, 90, 0, width),\n      0,\n      map(keyCode, 65, 90, 0, width),\n      height\n    );\n    osc.amp(0.05);\n    osc.start();\n    allOscs.push(osc);\n  }\n\n  switch (e.key) {\n    case \"a\":\n      for (let i = 0; i < allOscs.length; i++) {\n        allOscs[i].freq(allOscs[i].getFreq(), 0.7);\n        allOscs[i].amp(0, 0.1, 0.7);\n        //allOscs[i].stop();\n      }\n      allOscs = []\n      background(0);\n      break;\n    case \"1\":\n      oscType = \"square\";\n      break;\n    case \"2\":\n      oscType = \"sine\";\n      break;\n    case \"3\":\n      oscType = \"sawtooth\";\n      break;\n    case \"4\":\n      oscType = \"triangle\";\n      break;\n    case \"6\":\n      upDown = \"none\";\n      break;\n    case \"7\":\n      upDown = \"up\";\n      break;\n    case \"8\":\n      upDown = \"down\";\n      break;\n  }\n}\n\nfunction mousePressed() {\n  let osc = new p5.Oscillator();\n  osc.setType(oscType);\n  osc.freq(map(mouseX, 0, width, 100, 1200), map(mouseY, 0, height, 0.01, 1));\n  // osc.freq(constrain(200 + 1000 *(mouseY / height), 200, 1200))\n  stroke(255);\n  line(mouseX, 0, mouseX, height);\n  osc.amp(0.05, map(mouseY, 0, height, 0.01, 2));\n  osc.start();\n  allOscs.push(osc);\n}\n"
    }

  },
  {
    "id": "A21",
    "title": "rats_remix_farm_party",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["processed_audio","processed_image","synthesized_text"], 
      "interaction": ["human_interaction", "computer_interaction"], 
      "outcome": ["visual", "auditory", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"rats_remix_farm_party",
      "extension":".js",
      "content":"/*\nGurkirat Saini\ngssaini\nRats (Remix by barbara_im)\n\nOriginal: https://editor.p5js.org/gssaini117/sketches/rzAbNaPNd\n\nInstructions: Simply move the mouse across the screen like a slider and enjoy. \n\nMusic: https://www.youtube.com/watch?v=vdVnnMOTe3Q\n\nThe Remix!\nby barbara_im -> Barbara Irarrazaval\n\nSounds from https://freesound.org/\nFeel free to play with the patterns of the animal!\n*/\n\nlet dogPattern = [1, 0, 0, 1, 0, 0]\nlet chickenPattern = [1, 0, 1, 0, 1, 0]\nlet catPattern = [1, 1, 0, 0, 1, 0]\nlet sheepPattern = [0, 1, 0, 1, 0, 1]\nlet part;\nlet isPlaying = false;\n\nfunction preload() {\n  rat = loadImage('assets/rat.png');\n  mixtape = loadSound('assets/mixtape.mp3');\n  \n  dogsSound = loadSound('assets/24965__www-bonson-ca__bigdogbarking-02.wav');\n  dog = loadImage('assets/dog-5276317_1280.webp');\n  chickSound = loadSound('assets/316920__rudmer-rotteveel__chicken-single-alarm-call.wav');\n  chicken = loadImage('assets/chik.png');\n  sheepSound = loadSound('assets/34538__erdie__sheep.flac');\n  sheep = loadImage('assets/sheep_PNG2718.png');\n  catSound = loadSound('assets/4914__noisecollector__cat2.wav');\n  cat = loadImage('assets/cat.png');\n  \n  cricketSound = loadSound('assets/337435__ev-dawg__cricket.wav');\n  cricket = loadImage('assets/cricket_insect_PNG16.png');\n  vinilSound = loadSound('assets/162493__tasmanianpower__vinyl-rewind.wav');\n  oldSchoolSound = loadSound('assets/74522__laurencehr__pose1.mp3');\n  peopleSound = loadSound('assets/23153__freqman__party-sounds2.wav');\n}\n\nfunction setup() {\n  createCanvas(600, 400);\n  mixtape.loop();\n  ratAmp = new p5.Amplitude();\n  ratAmp.setInput(mixtape);\n\n  let dogPhrase = new p5.Phrase(dogsSound, playDog, dogPattern);\n  let chickenPhrase = new p5.Phrase(chickSound, playChicken, chickenPattern);\n  let catPhrase = new p5.Phrase(catSound, playCat, catPattern);\n  let sheepPhrase = new p5.Phrase(sheepSound, playSheep, sheepPattern);\n  part = new p5.Part();\n  part.addPhrase(dogPhrase);\n  part.addPhrase(chickenPhrase)\n  part.addPhrase(catPhrase);\n  part.addPhrase(sheepPhrase);\n  part.setBPM(10);\n  part.start(); \n  part.loop();\n\n  //dogsSound.loop()\n  //dogsSound.amp(1)\n  dogAmp = new p5.Amplitude();\n  dogAmp.setInput(dogsSound)\n  //chickSound.loop()\n  //chickSound.amp(0.5)\n  chickAmp = new p5.Amplitude();\n  chickAmp.setInput(chickSound)\n  //sheepSound.loop()\n  //sheepSound.amp(1.2)\n  sheepAmp = new p5.Amplitude();\n  sheepAmp.setInput(sheepSound)\n  //catSound.loop()\n  //catSound.amp(0.5)\n  catAmp = new p5.Amplitude();\n  catAmp.setInput(catSound)\n  \n  cricketAmp  = new p5.Amplitude();\n  cricketAmp.setInput(cricketSound);\n  cricketSound.amp(30)\n    \n\n  \n}\n\nfunction draw() {\n  background(220);\n  //mouseX controls volume\n  let volume = map(mouseX, 0, width, 0, 1);\n  volume = constrain(volume, 0, 1);\n  mixtape.amp(volume);\n  // controls the rat in relation to the mouse\n  let ratWidth = mouseX+50;\n  let ratHeight = ratAmp.getLevel() * height + ratWidth*2/3;\n  \n  \n  \n  image(dog, 0, 0, width/4, animalHeight(dogAmp))\n  image(chicken, width/4, 0, width/4, animalHeight(chickAmp))\n  image(cat, 2*width/4, 0, width/4, animalHeight(catAmp))\n  image(sheep, 3*width/4, 0, width/4, animalHeight(sheepAmp))\n  \n  image(rat, mouseX-ratWidth/2, height/2-ratHeight/2, ratWidth, ratHeight);\n  \n  text(\"Some commands:\", width/8, 6.5*height/8);\n  text(\"p: people, c: crickets, v: vinil in reverse, o: some old school music ;)\", width/8, 7*height/8);\n}\n\n\nfunction keyPressed(e) {\n  if (e.key == 'c') {\n    cricketSound.play();\n  } else if(e.key == 'o'){\n    oldSchoolSound.play();\n  }else if(e.key==\"v\"){\n    vinilSound.play();\n  }else if(e.key == \"p\"){\n    peopleSound.play()\n  }else {\n    value = 0;\n  }\n}\n\nfunction animalHeight(amp){\n  return amp.getLevel() * height + width/4*2/3;\n}\n\nfunction playDog(time, rate) {\n  dogsSound.rate(rate);\n  dogsSound.play(time);\n}\n\nfunction playCat(time, rate) {\n  catSound.rate(rate);\n  catSound.play(time);\n}\n\n\nfunction playSheep(time, rate) {\n  sheepSound.rate(rate);\n  sheepSound.play(time);\n}\n\n\nfunction playChicken(time, rate) {\n  chickSound.rate(rate);\n  chickSound.play(time);\n}\n"
    }
  },
  {
    "id": "A22",
    "title": "Strange_Things_Facemesh_Webcam_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["synthesized_image","randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Strange_Things_Facemesh_Webcam_sketch",
      "extension":".js",
      "content":"let facemesh;\nlet video;\nlet predictions = [];\nlet origins = {}\nlet [lastX, lastY] = [0,0];\nlet frameCounts = 0;\nlet pointCount = 0;\n\n\nlet mode = \"other\";\n\nfunction setup() {\n  createCanvas(640, 480);\n  video = createCapture(VIDEO);\n  video.size(width, height);\n\n  facemesh = ml5.facemesh(video, modelReady);\n\n  // This sets up an event that fills the global variable \"predictions\"\n  // with an array every time new predictions are made\n  facemesh.on(\"predict\", results => {\n    predictions = results;\n  });\n\n  // Hide the video element, and just show the canvas\n  video.hide();\n}\n\nfunction modelReady() {\n  console.log(\"Model ready!\");\n}\n\nfunction draw() {\n  image(video, 0, 0, width, height);\n\n  // We can call both functions to draw all keypoints\n  drawKeypoints();\n  \n}\n\n\nfunction keyPressed() {\n  if (mode === \"mask\") {\n    mode = \"lines\";\n  } else if (mode === \"other\"){\n    mode = \"mask\";\n  }else {\n    mode = \"other\";\n  }\n}\n\n// A function to draw ellipses over the detected keypoints\nfunction drawKeypoints() {\n  \n  for (let i = 0; i < predictions.length; i += 1) {\n    const keypoints = predictions[i].scaledMesh;\n\n    // Draw facial keypoints.\n    for (let j = 0; j < keypoints.length; j += 1) {\n      \n      const [x, y] = keypoints[j];\n\n      //line(x, y, lastX, lastY)\n      fill(0, 255, 0);\n      \n      //[lastX, lastY] = [x, y]\n      \n      \n      if (mode == \"mask\"){\n        //stroke(map(x, 0, width, 0, 255), map(y, 0, height, 0, 255), 0);\n        line(x, y, map(x, 0, width, mouseX -300, mouseX+300), map(y, 0, width,  mouseY -300, mouseY+300))\n      fill(map(x, 0, width, 0, 255), map(y, 0, height, 0, 255), 0);\n      ellipse(map(x, 0, width, mouseX -300, mouseX + 300), map(y, 0, width,  mouseY -300, mouseY+300), 7, 7);\n        \n      }else if (mode == \"lines\"){\n        pointCount += 1;\n        //stroke(map(x, 0, width, 0, 255), map(y, 0, height, 0, 255), 0);\n        line(x, y, lastX, lastY);\n\n        [lastX, lastY] = [x, y]\n        \n      }else{\n        fill(220)\n        quad(x, y, x+random(1,10), y, x+random(1,30), y+random(1,20), x, y+random(1,20))\n        quad(x, y, x-random(1,10), y, x-random(1,30), y+random(1,20), x, y+random(1,20))\n        //ellipse(x, y, 7, 7);\n      }\n      \n    }\n  }\n  \n}\n\n"
    }



  },
  {
    "id": "A23",
    "title": "Telar_sketch",
    "artist": "barbaraim",
    "year": "2020",
    "repoUrl": "https://github.com/barbaraim/Creative-Coding-Portfolio/tree/main",
    "classification":{
      "material_and_processes": ["synthesized_image","randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Telar_sketch",
      "extension":".js",
      "content":"let type = \"cloth\";\nlet stepSize = 16;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  video = createCapture(VIDEO);\n  video.size(windowWidth, windowHeight);\n  video.hide();\n  background(0);\n}\n\nfunction draw() {\n  video.loadPixels();\n  if (type == \"cloth\") {\n    tela();\n  } else if (type == \"beads\") {\n    beads();\n  }\n}\n\nfunction keyPressed() {\n  if (keyCode == 67) {\n    type = \"cloth\";\n  } else if (keyCode == 66) {\n    type = \"beads\";\n  }\n}\n\nfunction tela() {\n  let W = video.width;\n  let h = video.height;\n  //image(video,0,0)\n  let randomW = int(random(W));\n  let randomW2 = int(random(W));\n  let randomH = int(random(h));\n\n  let randomH2 = int(random(h));\n  let stitchSize = int(random(50));\n\n  if (mouseIsPressed) {\n    copy(video, randomW, 0, stitchSize, h, randomW2, 0, stitchSize, h);\n    copy(video, 0, randomH, W, stitchSize, 0, randomH2, W, stitchSize);\n\n    if (keyIsDown(49)) {\n      filter(GRAY);\n    } else if (keyIsDown(50)) {\n      filter(INVERT);\n    }\n\n    video.updatePixels();\n  }\n}\n\nfunction beads() {\n  for (let y = 0; y < height; y += stepSize) {\n    for (let x = 0; x < width; x += stepSize) {\n      const i = (y * width + x) * 4;\n      fill(\n        video.pixels[i],\n        video.pixels[i + 1],\n        video.pixels[i + 2],\n        video.pixels[i + 3]\n      );\n      circle(x, y, video.pixels[i] / 5);\n    }\n  }\n\n  if (keyIsDown(38)) {\n    stepSize += 1;\n  } else if (keyIsDown(40) && stepSize > 1) {\n    stepSize -= 1;\n  }\n}\n"
    }



  },
  {
    "id": "A24",
    "title": "Week_1_Drawing_pt2_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["synthesized_image"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Week_1_Drawing_pt2_sketch",
      "extension":".js",
      "content":"let slider;\nlet slider1;\n\nfunction setup() {\n  createCanvas(710, 400);\n  background(0);\n  colorMode(HSB);\n  \n  label = createDiv('Color');\n  label.position(0, 400);\n  slider = createSlider(0, 255, 255);\n  slider.position(0, 415);\n  \n  \n  label1 = createDiv('Stroke Size')\n  label1.position(0, 430);\n  slider1 = createSlider(1, 10, 5);\n  slider1.position(0, 450);\n}\n\n\n\nfunction draw() {\n  stroke(slider.value(), 100, 100);\n  strokeWeight(slider1.value());\n  if (mouseIsPressed === true) {\n    drawLine(mouseX, mouseY, pmouseX, pmouseY);\n    drawLine(width-mouseX, mouseY, width-pmouseX, pmouseY)\n    drawSquare(10, 10, 20);\n  }\n}\n\nfunction drawLine(mx, my, pmx, pmy) {\n  line(mx, my, pmx, pmy);\n}\n\nfunction drawSquare(w, h, c) {\n  fill(slider.value(), 100, 100, 127);\n  square(w, h, c);\n}"
    }



  },
  {
    "id": "A25",
    "title": "Week_1_Drawing_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["synthesized_image","randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "static"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Week_1_Drawing_sketch",
      "extension":".js",
      "content":"function setup() {\n  createCanvas(800, 800);\n  \n  background(0);\n\n  \n  for (let i = 0; i < 100; i++) {\n    var x = random(0, 800);\n    var y = random(0, 800);\n    var r = 5;\n    fill(\"yellow\");\n    circle(x, y, r);\n  }\n  \n  for (let i = 0; i < 200; i++) {\n    var l = random(0, 800);\n    var z = random(0, 800);\n    fill(\"white\");\n    circle(l, z, 5);\n  }\n  \n\n  \n  fill(192,192,192);\n  circle(100, 100, 150);\n  fill(40, 122, 184);\n  arc(400, 900, 600, 500, PI, 0, CHORD);\n  \n  fill(52, 165, 111);\n  circle(184, 770, 60);\n  \n  fill(255);\n  circle(600, 400, 60);\n  fill(52, 165, 111);\n  circle(457, 770, 200);\n  \n  fill(105,105,105);\n  circle(136,110, 40);\n  fill(105,105,105);\n  circle(64, 125, 60);\n  circle(100, 41, 30);\n  \n  \n  stroke(\"white\");\n  strokeWeight(3);\n  line(607, 388, 412, 127);\n  line(588, 401, 325, 326);\n  line(577, 377, 370, 210);\n  \n  stroke(\"blue\");\n  strokeWeight(3);\n  line(593, 371, 445, 84);\n  line(570, 395, 273, 336);\n  line(570, 395, 348, 244);\n  line(593, 371, 378, 178);\n  \n  stroke(\"cyan\");\n  line(392, 371, 349, 354);\n  line(517, 175, 525, 206);\n  line(388, 311, 415, 335);\n  line(459, 318, 500, 324);\n  line(574, 257, 585, 286);\n  line(542, 388, 484, 387);\n  line(534, 261, 554, 314);\n  \n  stroke(\"grey\");\n  \n  textSize(32);\n  fill(255);\n  text(\"The Starry Sky\", 561, 50);\n}\n\nfunction draw() {\n  // text(\"x: \" + mouseX,10,20); // displays the mouse's x location\n  // text(\"y: \" + mouseY,10,40); // displays the mouse's y location\n  // stroke(\"white\");\n}"
    }
  },
  {
    "id": "A26",
    "title": "Week_2_Live_Video_Processing_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["synthesized_image"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Week_2_Live_Video_Processing_sketch",
      "extension":".js",
      "content":"let webCam;\n\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  pixelDensity(1);\n  webCam = createCapture(VIDEO);\n  webCam.size(windowWidth, windowHeight);\n  webCam.hide();\n  noStroke();\n  fill(0);\n  \n  \n\n}\n\nfunction draw() {\n  background(255);\n  webCam.loadPixels();\n  stepSize = 4\n  image(webCam, 0, 0, width, width * webCam.height / (webCam.width)/2);\n  filter(INVERT);\n  \n//   webCam.loadPixels();\n//   for(let y = 0; y < webCam.height; y+=10) {\n//     // Visit every column of pixels\n//     for(let x = 0; x < webCam.width; x+=10) {\n//       // Get the color array [r,g,b,a] at x,y\n//       let colorOfCamAtXY = webCam.get(x,y);\n      \n//       // Use that color as fill\n//       //fill(colorOfCamAtXY);\n      \n//       // Extract the brightness level of the color\n//       let b = brightness(colorOfCamAtXY);\n//       // Test for a brightness threshold of 50\n//       if(b > 50) fill('white');\n//       else fill('black');\n      \n//       // Draw a 10x10 rectangle at x,y\n//       rect(x, y, 10, 10);\n//     }\n//   }\n  \n\n  translate(width, 0);\n  scale(-1, 1);\n  image(webCam, 0, height/2, width, width * webCam.height / (webCam.width)/2);\n\n\n  filter(INVERT);\n\n  \n\n  \n}"
    }



  },
  {
    "id": "A27",
    "title": "Week_3_Patterns_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["synthesized_image"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Week_3_Patterns_sketch",
      "extension":".js",
      "content":"let angle = 0.0\nlet speed = 0.05\n\nfunction setup() {\n  createCanvas(700, 700);\n  rectMode(CENTER)\n}\n\n\nfunction draw() {\n  \n  background(0);\n  \n  translate(width/2, height/2)\n  \n\n  rotate(angle/10)\n  for (let i = 50; i < 700; i += 40) {\n      rotate(-angle/100)\n    for (let j = 50; j < 700; j += 40) {\n      rotate(angle/300)\n      push()\n \n      noFill()\n      stroke(mouseX - i, i, mouseY - j)  //color\n      strokeWeight(3)\n      \n      shearY(3.0)\n      shearX(2.0)\n    \n      let d = dist(700, 700, i +width/2, j +height/2)\n      \n      let r = d/5\n      \n      ellipse(i, j, r - 20, r - 20)\n\n      ellipse(i, j, r, r)     \n      \n      pop()\n      \n      angle+=0.0003\n    }\n  }\n}"
    }



  },
  {
    "id": "A28",
    "title": "Week_4_Sound_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["processed_audio","synthesized_image","interactions"], 
      "interaction": ["human_interaction", "computer_interaction"], 
      "outcome": ["visual", "auditory", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Week_4_Sound_sketch",
      "extension":".js",
      "content":"//Leon Chen Week 4: Sound\n//Play button to play the song and Volume and Speed sliders to change up the speed and amplitutde to see change on canvas\n//Audio File is called Pure-Sky from Genshin Impact\n\nlet slider;\nlet slider1;\nlet song;\nlet amp;\nlet fft;\n\nfunction preload() {\n  song = loadSound('Sky.mp3')\n  //amp = new p5.Amplitude();\n}\n\nfunction setup() {\n  createCanvas(400, 400);\n  slider = createSlider(0.0, 2.0, 0.2, 0.1);\n  slider.position(0, 450);\n\n  label = createDiv('Volume')\n  label.position(0, 435);\n  \n  slider1 = createSlider(0.1, 4.0, 1.0, 0.1 );\n  slider1.position(0, 495)\n  \n  label = createDiv('Speed')\n  label.position(0, 480);\n  \n  \n  \n  button = createButton('Play')\n  button.position(0, 405)\n  button.mousePressed(Play)\n  \n \n  fft = new p5.FFT();\n  fft.setInput(song)\n  \n  \n}\n\nfunction draw() {\n  background(0);\n  \n  song.setVolume(slider.value());\n  //song.setSpeed(slider1.value());\n  \n  speed = constrain(slider1.value(), 0.1, 4);\n  song.rate(speed);\n  \n  \n  let spectrum = fft.analyze()\n  beginShape();\n  for (i = 0; i < spectrum.length; i++) {\n    vertex(i, map(spectrum[i], 0, 255, height, 0));\n  }\n  endShape();\n  \n  \n}\n\nfunction Play() {\n    if (!song.isPlaying()) {\n    song.play();\n    button.html(\"Stop\");\n\n  } else {\n    song.pause();\n    button.html(\"Play\");\n\n  }\n}"
    }
  },
  {
    "id": "A29",
    "title": "Week_5_Sound_pt2_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["processed_audio","synthesized_image","interactions"], 
      "interaction": ["human_interaction", "computer_interaction"], 
      "outcome": ["visual", "auditory", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Week_5_Sound_pt2_sketch",
      "extension":".js",
      "content":"\nlet song;\nlet fft;\nlet degree = 10.0;\nlet dt = 0.1;\n\n\nfunction preload() {\n  song = loadSound(\"Sky.mp3\");\n}\nfunction setup() {\n  let cnv = createCanvas(400, 400);\n  fft = new p5.FFT(0.9, 64);\n  song.amp(0.4);\n}\nfunction mousePressed() {\n  if (song.isPlaying()) {\n    song.stop();\n  } else {\n    song.play();\n  }\n}\n\nfunction analyze(r) {\n  let spectrum = fft.analyze();\n  fill(255);\n  for (let i = 0; i < spectrum.length; i++) {\n    \n    let x = map(i, 0, spectrum.length, 0, height);\n    \n    let theta = map(i, 0, spectrum.length, 0, 2 * PI);\n    \n    let h = constrain(-height + map(spectrum[i], 0, 255, height, 0), -200, 200);\n    \n   \n    if (h >= -20) h = -70;\n   \n    \n    let xCoord = h * cos(theta);\n    let yCoord = h * sin(theta);\n    \n    stroke(147, 112 , 219)\n    fill(75, 0, 130)\n    circle(xCoord, yCoord, 5); //tips\n    strokeWeight(3);\n    stroke(135, 206, 250); //lines\n    line(0, 0, xCoord, yCoord);\n    \n    //shearX(2.0)\n    //shearY(4.0)\n    shearX(6.0)\n    shearY(4.0)\n  }\n\n}\n\nfunction waveform() {\n  let r = 0;\n  let lastR = 20; //changes circle size\n  let waveform = fft.waveform();\n  for (let i = 0; i < waveform.length; i++)\n    if (r <= waveform[i]) r = waveform[i];\n  let y = map(waveform[waveform.length - 1], -10, 10, 0, height);\n  r = r * 500 + 100;\n  analyze((r - lastR) * dt * 10);\n  fill(147, 112, 219);\n  circle(0, 0, (r - lastR) * dt * 5);//big circle\n  lastR = r;\n  \n}\n\n\nfunction waveform1() {\n  let r = 0;\n  let lastR = 20; //changes circle size\n  let waveform = fft.waveform();\n  for (let i = 0; i < waveform.length; i++)\n    if (r <= waveform[i]) r = waveform[i];\n  let y = map(waveform[waveform.length - 1], -10, 10, 0, height);\n  r = r * 500 + 100;\n  //analyze((r - lastR) * dt * 0);\n  fill(147, 112, 219);\n  circle(0, 0, (r - lastR) * dt * 3);//big circle\n  lastR = r;\n  \n}\n\n\nfunction waveform2() {\n  let r = 0;\n  let lastR = 20; //changes circle size\n  let waveform = fft.waveform();\n  for (let i = 0; i < waveform.length; i++)\n    if (r <= waveform[i]) r = waveform[i];\n  let y = map(waveform[waveform.length - 1], -100, 10, 0, width);\n  r = r * 500 + 100;\n  //analyze((r - lastR) * dt * 10);\n  fill(147, 112, 219);\n  circle(400, 400, (r - lastR) * dt * 3);//big circle\n  lastR = r;\n  \n}\n\n\nfunction waveform3() {\n  let r = 0;\n  let lastR = 20; //changes circle size\n  let waveform = fft.waveform();\n  for (let i = 0; i < waveform.length; i++)\n    if (r <= waveform[i]) r = waveform[i];\n  let y = map(waveform[waveform.length - 1], -100, 10, 0, width);\n  r = r * 500 + 100;\n  //analyze((r - lastR) * dt * 10);\n  for (let i = 0; i < 10; i++) {\n    var l = random(0, 400)\n    var z = random(0, 400)\n    fill(255);\n    circle(l, z, (r - lastR) * dt * 0.5);//big circle\n  }\n\n  lastR = r;\n  \n}\n\n\nfunction draw() {\n  background(230, 230, 250);\n  push();\n  waveform1();\n  waveform2();\n  waveform3();\n  translate(width / 2, height / 2);\n  //translate(width, height)\n  rotate(radians(degree));\n  //rotate(radians(HALF_PI))\n  waveform();\n  waveform1();\n  waveform2();\n  degree++;\n  pop();\n  \n  \n\n}"
    }
  },
  {
    "id": "A30",
    "title": "Week_6_3D_WEBGL_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["processed_image","synthesized_image"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Week_6_3D_WEBGL_sketch",
      "extension":".js",
      "content":"function setup() {\n  createCanvas(400, 400, WEBGL);\n  img = loadImage('Galaxys.jpg'); //texture\n}\n\nfunction draw() {\n  background(0);\n  \n  \n  push();\n  //ambientLight(205, 0, 0);\n  rotateZ(frameCount - 0.01);\n  //rotateX(frameCount * 0.01);\n  rotateY(frameCount * 0.01);\n  texture(img);\n  box(25);\n  pop();\n  \n  push();\n  ambientLight(225, 225, 0); //light (supposed to be yellow)\n  \n  translate(69, 0)\n  //normalMaterial();  //color\n  rotateZ(frameCount + 0.5);\n  rotateX(frameCount * 0.05);\n  rotateY(frameCount * 0.05);\n  sphere(10, 20);\n  pop();\n  \n  \n\n  push();\n  ambientLight(225, 225, 0);\n  \n  translate(0,-100)\n  //normalMaterial();  //color\n  rotateZ(frameCount + 0.05);\n  rotateX(frameCount * 0.05);\n  rotateY(frameCount * 0.05);\n  sphere(10, 20);\n  pop();\n  \n  \n  \n  push();\n  ambientLight(225, 225, 0);\n  \n  translate(0,100)\n  //normalMaterial();  //color\n  rotateZ(frameCount * 0.05);\n  rotateX(frameCount * 0.05);\n  rotateY(frameCount * 0.05);\n  sphere(10, 20);\n  pop();\n  \n  \n  \n  push();\n  ambientLight(225, 225, 0);\n  \n  translate(-69,0)\n  //normalMaterial();  //color\n  rotateZ(frameCount + 0.05);\n  rotateX(frameCount * 0.05);\n  rotateY(frameCount * 0.05);\n  sphere(10, 20);\n  pop();\n  \n  \n  \n  //normalMaterial();  //color\n  push();\n  normalMaterial();  //color\n  rotateZ(frameCount * 0.01);\n  rotateX(frameCount * 0.01);\n  rotateY(frameCount * 0.01);\n  torus(90, 2);\n  pop();\n  \n  push();\n  normalMaterial();  //color\n  rotateZ(frameCount * 0.03);\n  rotateX(frameCount * 0.03);\n  rotateY(frameCount * 0.03);\n  torus(75, 2);\n  pop();\n  \n  push();\n  normalMaterial();  //color\n  rotateZ(frameCount * 0.02);\n  rotateX(frameCount * 0.02);\n  rotateY(frameCount * 0.02);\n  torus(85, 2);\n  pop();\n  \n  \n  push();\n  normalMaterial();  //color\n  rotateZ(frameCount * 0.04);\n  rotateX(frameCount * 0.04);\n  rotateY(frameCount * 0.04);\n  torus(98, 2);\n  pop();\n  \n  \n  push();\n  normalMaterial();  //Material\n  rotateZ(frameCount * 0.05);\n  rotateX(frameCount * 0.05);\n  rotateY(frameCount * 0.05);\n  torus(95, 2);\n  pop();\n  \n  \n\n  \n}"
    }
  },
  {
    "id": "A31",
    "title": "Week_7_Text_Poetry_sketch",
    "artist": "cleonc13",
    "year": "2020",
    "repoUrl": "https://github.com/cleonc13/Creative-Coding-Projects",
    "classification":{
      "material_and_processes": ["synthesized_text","randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Week_7_Text_Poetry_sketch",
      "extension":".js",
      "content":"let sourceText = \"Sleep\";\nlet source1 = \"Time\"\nlet source2 = \"Money\"\nlet source3 = \"Happiness\"\n\nconst word = \"stress\"\n\nfunction setup() {\n  createCanvas(700, 700);\n  frameRate(100);\n  font = textFont('ZCOOL QingKe HuangYou');\n}\n\nfunction draw() {\n  background(0);\n  \n  //font = textFont('ZCOOL QingKe HuangYou');\n  textSize(100);\n  fill(255)\n  textLeading( (mouseX / height) * 100);\n  textSize(50)\n  fill(187, 161, 79)\n  text(\"Things That I Want More In My Life\", width/2 - 100, height/32, 100)\n  fill(225, 0, 0)\n  \n  textAlign(CENTER, CENTER);\n  let middle = sourceText.length / 2;\n  let left = middle - ((mouseX / width) * middle);\n  let right = middle + ((mouseX / width) * middle);\n  text(\n    sourceText.substring(left, right+1),\n    100, 100);\n  text(\n    source1.substring(left, right+1),\n    175, 500);\n  text(\n    source2.substring(left, right+1),\n    575, 300);\n  text(\n    source3.substring(left, right+5),\n    600, 600);\n  \n  for(let i = 0; i<20; i++){\n  const rand = int(random(0, word.length-1));\n  fill(255);\n  textSize(random(5, 50));\n  text(word, random(width), random(height));\n  \n  }\n}\n"
    }
  },
  {
    "id": "A32",
    "title": "bezir_curves_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes":["synthesized_image", "randomness"],
      "interaction": ["none"], 
      "outcome": ["visual", "static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"bezir_curves_sketch",
      "extension":".js",
      "content":"var t;\nlet a = 0.001\nlet speed = 0.0005\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n\n    background(0);\n    stroke(255, 0, 0, 200);\n    noFill();\n    t = 0;\n}\n\nfunction draw() {\n    var x1 = width / 2*noise(t+15);\n    var x2 = width / 2 * noise(t + 25);\n    var x3 = width / 2 * noise(t + 35);\n    var x4 = width / 2 * noise(t + 45);\n    var y1 = height / 2 * noise(t + 55);\n    var y2 = height / 2 * noise(t + 65);\n    var y3 = height / 2 * noise(t + 75);\n    var y4 = height / 2 * noise(t + 85);\n\n    translate(width / 2, height / 2)\n    rotate(frameCount / 100);\n\n    if (a > 1.5 || a < 0.001) {\n        speed *= -1\n    }\n    a += speed\n\n    scale(a)\n    a += speed;\n\n    bezier(x1, y1, x2, y2, x3, y3, x4, y4);\n\n\n    t += 0.005;\n}\n"
    }


  },
  {
    "id": "A33",
    "title": "bezir_ribbons_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes":["synthesized_image", "randomness"],
      "interaction": ["none"], 
      "outcome": ["visual", "static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"bezir_ribbons_sketch",
      "extension":".js",
      "content":"// var x1 = -20, x2 = -100, x3 = -10, x4 = -105;\n// x = [-20, -100, -10, -105]\nlet num = 3;\nribbons = []\n\n// let x = [-20, -100, -10, -105];\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    colorMode(HSB, 360, 100, 100, 100);\n    background(262, 100, 17);\n    noFill();\n    let t = 0;\n    palette1 = [color(274, 51, 100, 35), color(10, 35, 100, 10), color(173, 73, 62, 25)]\n    palette2 = [color(43, 55, 91, 45), color(27, 60, 96, 20), color(9, 18, 99, 20)]\n    let x = [-20, -100, -10, -105];\n    ribbons.push(new Ribbon(palette1[0], 1.5*height, x, 50, 17, 0.8, 0.001));\n    // ribbons.push(new Ribbon(palette1[1], 1.5*height, x, 50, 17, 0.8, 0.002));\n    ribbons.push(new Ribbon(palette1[2], height, x, 50, 17, 0.8, 0.003));\n    // ribbons.push(new Ribbon(palette2[0], height, x, 25, 15, 0.6, 0.004));\n    ribbons.push(new Ribbon(palette2[1], height/2, x, 30, 20, 0.6, 0.005));\n    // ribbons.push(new Ribbon(palette2[2], 0, x, 30, 20, 0.8, 0.006));\n\n\n}\n\nfunction draw() {\n\n    for(let ribbon of ribbons)\n        ribbon.update();\n\n}\n\n\nclass Ribbon {\n\n    constructor(c, ypos, x, lenght, thickness, speed, incr) {\n        this.c = c;\n        this.ypos = ypos;\n        this.lenght = lenght;\n        this.thickness = thickness;\n        this.speed = speed;\n        this.x = x;\n        this.t = 0;\n        this.increment = incr;\n    }\n\n    update() {\n\n        stroke(this.c);\n        strokeWeight(this.thickness);\n\n        var y1 = (this.ypos + this.lenght) * noise(this.t + 5);\n        var y2 = (this.ypos + this.lenght) * noise(this.t + 5);\n        var y3 = this.ypos * noise(this.t + 10);\n        var y4 = this.ypos * noise(this.t + 15);\n\n        for(let i = 0; i < 4; i++){\n            this.x[i] += this.speed;\n        }\n        bezier(this.x[0], y1, this.x[1], y2, this.x[2], y3, this.x[3], y4);\n        if (this.x[1] > width) noLoop();\n        this.t += this.increment;\n    }\n}\n\n"
    }
  },
  {
    "id": "A34",
    "title": "blobby_007_sketch",
    "artist": "HouCoder",
    "year": "2020",
    "repoUrl": "https://github.com/HouCoder/Creative-Coding",
    "classification":{
      "material_and_processes":["synthesized_image"],
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"blobby_007_sketch",
      "extension":".js",
      "content":"let num = 200;\nlet yoff = 0;\nlet t =0;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n}\n\nfunction draw() {\n  blendMode(BLEND);\n  background(0);\n blendMode(ADD);\n  noStroke();\n  translate(width/2,height/2);\n   fill(255, 0, 0);\n  bobby(noise(t/2)*200-100,noise(t/2+1)*200-100,1,80);\n    fill(0, 255, 0);\n   bobby(noise(t/4+4)*200-100,noise(t/2+3)*200-100,2,80);\n    fill(0, 0, 255);\n   bobby(noise(t/4+6)*200-100,noise(t/2+5)*200-100,3,80)\n  t+=0.001;\n}\n\nfunction bobby(xPos,yPos,zoff,radium) {\n  let xoff = 0;\n\n  push();\n    beginShape();\n  for (let a = 0; a < num; a += 0.1) {\n    let offset = map(noise(xoff, yoff,zoff), 0, 1, -25, 25);\n    let r = radium + offset;\n    let x = r * cos(a)+xPos;\n    let y = r * sin(a)+yPos;\n    curveVertex(x,y);\n    xoff+=0.08;\n    zoff+=0.005;\n  }\n  endShape();\n  pop();\n  \n\n  yoff += 0.01;\n\n\n}"
    }


  },
  {
    "id": "A35",
    "title": "blob_petals_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes":["synthesized_image"],
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"blob_petals_sketch",
      "extension":".js",
      "content":"let kMax;\nlet step;\nlet n = 14;\nlet radius = 0;\nlet inter = 0.1;\nlet maxNoise = 300;\n\nlet noiseProg = (x) => (sqrt(x));\n\n\nfunction setup () {\n    createCanvas(window.innerWidth, window.innerHeight);\n    colorMode(HSB, 1);\n    angleMode(DEGREES);\n    kMax = 1;\n    step = 1;\n    strokeWeight(2);\n    stroke(0);\n}\n\n\nfunction draw () {\n    background(0);\n\n    let t = frameCount/400;\n\n\n    for(let i = n; i > 0; i--) {\n        let alpha = 1 - noiseProg(i/n);\n\n        if(i%2){\n            fill(0, 1-alpha);\n            stroke(0.66, 1, 1, 0.8);\n        }\n        else{\n            fill(0.66, 1, 1, 0.8);\n            stroke(0, 0.8);\n        }\n\n        let size = radius + i*inter + i*i/2;\n        let k = kMax*sqrt(i/n);\n        let noiseness = maxNoise*noiseProg(i/n);\n        blob(size, width/2, height/2, k, t+i*step, noiseness);\n    }\n    // fill(0);\n    // ellipse(width/2, height/2, 35);\n}\n\nfunction blob(size, xc, yc, k, t, noiseness) {\n    beginShape();\n    let angleStep = 360/90;\n    for(let theta = 0; theta < 360; theta += angleStep) {\n        let r1, r2;\n        r1 = cos(theta)+1;\n        r2 = sin(theta)+1;\n        let r = size+noise(k*r1, k*r2, t)*noiseness;\n        let x = xc + r*cos(theta);\n        let y = yc + r*sin(theta);\n        curveVertex(x, y);\n    }\n    endShape(CLOSE);\n}"
    }


  },
  {
    "id": "A36",
    "title": "blob_template_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes":["synthesized_image"],
      "interaction": ["none"], 
      "outcome": ["visual", "static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"blob_template_sketch",
      "extension":".js",
      "content":"let kMax;\nlet step;\nlet n = 200; // number of blobs\nlet radius = 20; // diameter of the circle\nlet inter = 0.05; // difference between the sizes of two blobs\nlet maxNoise = 352;\n\nlet noiseProg = (x) => (x*x);\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n    colorMode(HSB, 360, 100, 100, 1);\n    angleMode(DEGREES);\n    noFill();\n    noLoop();\n    kMax = 1;\n    step = 0.05;\n    noStroke();\n}\n\nfunction draw() {\n    background(1, 1, 0, 1);\n\n    let t = frameCount/400;\n    for (let i = n; i > 0; i--) {\n        let alpha = 1 - noiseProg(i / n);\n        fill((360*alpha / 5) % 360, 0, 100*(1-alpha), alpha);\n        let size = radius + i * inter;\n        let k = kMax * sqrt(i / n);\n        let noisiness = maxNoise * noiseProg(i / n);\n        blob(size, width / 2, height / 2, k, i * step + t, noisiness);\n    }\n}\n\nfunction blob(size, xCenter, yCenter, k, t, noisiness) {\n    beginShape();\n    let angleStep = 360 / 500;\n    for (let theta = 360; theta > 0; theta -= angleStep) {\n        let r1, r2;\n        r1 = cos(theta) + 1;\n        r2 = sin(theta) + 1;\n        let r = size + noise(k * r1, k * r2, t) * noisiness;\n        let x = xCenter + r*cos(theta);\n        let y = yCenter + r*sin(theta);\n        curveVertex(x, y);\n    }\n    endShape(CLOSE);\n}"
    }


  },
  {
    "id": "A37",
    "title": "brush_strokes_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["processed_audio","synthesized_image", "randomness"],
      "interaction": ["human_interaction"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"brush_strokes_sketch",
      "extension":".js",
      "content":"\n\n\nlet kMax;\nlet step;\nlet n = 50; // number of blobs\nlet radius = 0; // diameter of the circle\nlet inter = 0.5; // difference between the sizes of two blobs\nlet maxNoise = 400;\n\nlet noiseProg = (x) => (x*x);\nlet sound, amplitude;\n\n\nfunction preload() {\n    sound = loadSound('kanye.mp3');\n}\n\nfunction setup() {\n    let cnv = createCanvas(windowWidth, windowHeight);\n    cnv.mouseClicked(toggleSound);\n    amplitude = new p5.Amplitude();\n    colorMode(HSB, 360, 100, 100, 1);\n    angleMode(DEGREES);\n    noFill();\n    \n    noStroke();\n}\n\nfunction draw() {\n    background(1, 1, 0, 1);\n    let level = amplitude.getLevel();\n    woofer(level * 1.5, width / 2 - 50, height / 2, 5, 400, 20);\n    woofer(level, width / 8, height / 2, 1, 200, 50);\n    woofer(level, width - width / 6, height / 2, 1, 200, 50);\n    \n}\n\nfunction woofer(level, posx, posy, kconst, maxNoise, n)\n{\n    kMax = level * kconst;\n    step = 1;\n    let t = frameCount / 400;\n    for (let i = n; i > 0; i--) {\n        let alpha = 1 - noiseProg(i / n);\n        fill((720 * level) % 360, 80, 100 * (1 - alpha), alpha);\n        let size = radius + map(level, 0, 1, 0, 300);\n        let k = kMax * sqrt(i / n);\n        let noisiness = maxNoise * noiseProg(i / n);\n        blob(size, posx, posy, k, i * step + t, noisiness);\n    }\n}\n\nfunction blob(size, xCenter, yCenter, k, t, noisiness) {\n    beginShape();\n    let angleStep = 360 / 500;\n    for (let theta = 360; theta > 0; theta -= angleStep) {\n        let r1, r2;\n        r1 = cos(theta) + 1;\n        r2 = sin(theta) + 1;\n        let r = size + noise(k * r1, k * r2, t) * noisiness;\n        let x = xCenter + r*cos(theta);\n        let y = yCenter + r*sin(theta);\n        curveVertex(x, y);\n    }\n    endShape(CLOSE);\n}\n\nfunction toggleSound() {\n    if (sound.isPlaying()) {\n        sound.stop();\n    } else {\n        sound.play();\n    }\n}"
    }


  },
  {
    "id": "A38",
    "title": "cave_vision_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes":["synthesized_image"],
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"cave_vision_sketch",
      "extension":".js",
      "content":"let kMax;\nlet step;\nlet n = 300; // number of blobs\nlet r = 70;\nlet a = 75;\nlet b = 15;\nlet inter_r = 0.9   ;\nlet maxNoise = 400;\nlet i = 0;\n\nlet noiseProg = (x) => (x * x);\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    colorMode(HSB, 360, 100, 100, 1);\n    angleMode(DEGREES);\n    background(26, 16, 18);\n    \n    // strokeWeight(0.8);\n    noFill();\n    kMax = 1;\n    step = 0.02;\n}\n\nfunction draw() {\n    // background(278, 100, 72);\n\n    let t = frameCount / 400;\n    let radius = r + i * inter_r;\n\n    let k = kMax * sqrt(i / n);\n    let noisiness = maxNoise * noiseProg(i / n);\n    blob(radius, width / 2, 3 * height / 4, k, i * step + t, noisiness);\n    i+=1.1;\n\n    if(i > n) noLoop();\n}\n\nfunction blob(size, xCenter, yCenter, k, t, noisiness) {\n    beginShape();\n    let angleStep = 1;\n    for (let theta = 180; theta >= -180; theta -= angleStep) {\n\n        let r1, r2;\n        r1 = cos(theta) + 1;\n        r2 = sin(theta) + 1;\n        let r = size + noise(k * r1, k * r2, t) * noisiness;\n        if(theta <= 170 && theta  >= 10){\n            \n            if(theta == 45 || theta == 135)\n            {\n                stroke(4, 61, 98, 0.3);\n                let x = xCenter + r/3 * cos(theta);\n                let y = yCenter + r/3 * sin(theta);\n                curveVertex(x, y);\n            }\n            \n        }\n        else\n        {\n            stroke(4, 61, 98, 1);\n            let x = xCenter + r * cos(theta);\n            let y = yCenter + r * sin(theta);\n            curveVertex(x, y);\n        }\n    }\n    endShape(CLOSE);\n}"
    }


  },
  {
    "id": "A39",
    "title": "circular_blazes_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"circular_blazes_sketch",
      "extension":".js",
      "content":"let particles = [];\n\nlet n;\nlet squiggliness = 1/25;\nlet count = 150;\nlet maxSize = 250;\nlet interval;\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    colorMode(HSB, 100);\n\n    noStroke();\n    background(10);\n    updateParticles();\n}\n\n\nfunction draw() {\n    for(let p of particles) {\n        p.draw();\n        p.move();\n    }\n}\n\nfunction updateParticles() {\n    particles = [];\n    let r = count;\n    let hue = random(0, 100);\n    n = 10*count;\n\n    for (let i = 0; i < n; i++) {\n        let theta = map(i, 0, n, -PI, PI);\n        let x = width/2 + r*cos(theta);\n        let y = height/2 + r*sin(theta);\n\n        let size = random(3, 4.5);\n        let c = color(hue, random(90, 100), random(80, 100), 100);\n        particles.push(new Particle(x, y, size, c));\n    }\n}\n\nfunction Particle(x, y, size, c){\n    this.x = x;\n    this.y = y;\n    this.s = size;\n    this.c = c;\n\n    this.alpha = 100;\n    this.dist = 1;\n\n    this.move = function() {\n        let theta = noise(this.y *squiggliness, this.x*squiggliness)*PI*4;\n        let v = p5.Vector.fromAngle(theta, this.dist);\n\n        this.x += v.x;\n        this.y += v.y;\n\n        this.alpha *= 0.99;\n        this.s *= 0.99;\n\n    }\n\n    this.draw = function() {\n        this.c.setAlpha(this.alpha);\n        fill(this.c);\n        circle(this.x, this.y, this.s);\n        this.c.setAlpha(100);\n    }\n}"
    }


  },
  {
    "id": "A40",
    "title": "dot_effect_painting_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["processed_image", "synthesized_image","randomness"],
      "interaction": ["human_interaction"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"dot_effect_painting_sketch",
      "extension":".js",
      "content":"var image;\nvar balls = [];\nvar radiusLow;\nvar radiusHigh;\nvar rangeLow;\nvar rangeHigh;\n\n\nfunction preload() {\n    img = loadImage(\"venom.jpg\");\n}\n\nfunction setup() {\n    createCanvas(img.width, img.height);\n    background(255);\n    textAlign(CENTER);\n    text(\"Click and hold here!!\", width/2, height/2);\n}\n\nfunction draw() {\n    for(var i = 0; i < balls.length; i++) {\n        balls[i].draw();\n        balls[i].update();\n        balls[i].colorChange();\n    }\n    for(var i = 0; i < balls.length ; i++){\n        if(balls[i].radius < 0)\n            balls.splice(i, 1);\n    }\n    if(mouseIsPressed){\n        for(var i = 0; i< 5; i++){\n            balls.push(new Ball(mouseX, mouseY, color(img.get(mouseX+random(2), mouseX+random(2)) )));\n        }\n    }\n    console.log(frameRate);\n}\n\n\n\nclass Ball {\n    constructor(mX, mY, c){\n        this.location = createVector(mX, mY);\n        this.radius = random(10, 20);\n        this.r = red(c);\n        this.g = green(c);\n        this.b = blue(c);\n        this.xOff = 0.0;\n        this.yOff = 0.0;\n        this.radiusHigh;\n        this.radiusLow;\n        this.rangeHigh;\n        this.rangeLow;\n    }\n    update(){\n        this.radius -= random(0.15, 0.25);\n        this.xOff = this.xOff + random(-0.5, 0.5);\n        this.nX = noise(this.location.x)*this.xOff;\n        this.yOff = this.yOff + random(-0.5, 0.5);\n        this.nY = noise(this.location.y)*this.yOff;\n        this.location.x += this.nX;\n        this.location.y += this.nY;\n\n    }\n\n    colorChange() {\n        this.c = color(img.get(this.location.x, this.location.y));\n        this.r = red(this.c);\n        this.g = green(this.c);\n        this.b = blue(this.c);\n    }\n\n    draw() {\n        noStroke();\n        fill(this.r, this.g, this.b);\n        ellipse(this.location.x, this.location.y, this.radius, this. radius);    \n    }\n}"
    }


  },
  {
    "id": "A41",
    "title": "fire_vortex_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"fire_vortex_sketch",
      "extension":".js",
      "content":"let kMax;\nlet step;\nlet n = 200; // number of blobs\nlet radius = 20; // diameter of the circle\nlet inter = 0.5; // difference between the sizes of two blobs\nlet maxNoise = 352;\nlet maxShift = 20;\n\nlet pallete;\n\nlet noiseProg = (x) => (x*x);\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n    colorMode(HSB, 360, 100, 100, 100);\n    angleMode(DEGREES);\n    noFill();\n    kMax = 0.1;\n    step = 1;\n    pallete = [color(34, 98, 96, 40), color(12, 99, 86, 60), color(358, 99, 62, 60), color(339, 89, 22, 60)];\n    translate(width/2, height/2);\n    strokeWeight(10);\n    // noLoop();\n}\n\nfunction draw() {\n    background(0, 0, 0, 100);\n    translate(width / 2, height / 2);\n    let t = frameCount/400;\n    for (let i = 0; i < n; i++) {\n        let size = radius + i * inter;\n        let k = kMax * sqrt(i / n);\n        let noisiness = maxNoise * noiseProg(i / n);\n        rotate(frameCount);\n        translate(maxShift * noiseProg(i / n), maxShift * noiseProg(i / n))\n        blob(size, 0, 0, k, i * step + t, noisiness, i);\n    }\n}\n\nfunction blob(size, xCenter, yCenter, k, t, noisiness, i) {\n    beginShape();\n    stroke(pallete[i % 4]);\n    let angleStep = 360 / 100;\n    for (let theta = 360; theta > 0; theta -= angleStep) {\n        let r1, r2;\n        r1 = cos(theta) + 1;\n        r2 = sin(theta) + 1;\n        let r = size + noise(k * r1, k * r2, t) * noisiness;\n        let x = xCenter + r*cos(theta);\n        let y = yCenter + r*sin(theta);\n        curveVertex(x, y);\n    }\n    endShape(CLOSE);\n}"
    }


  },
  {
    "id": "A42",
    "title": "glitch_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "processed_image", 
      "randomness"], "interaction": ["none"], 
      "outcome": ["visual", "static"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"glitch_sketch",
      "extension":".js",
      "content":"var img;\nvar bandHeight = bandWidth = 30;\nvar bandMisalign = 60;\nlet pallete;\nfunction preload() {\n    img = loadImage('portrait.jpg');\n    pallete = [color(255, 0, 0, 100), color(0, 0, 255, 100), color(0, 255, 0, 100)];\n}\nfunction setup() {\n    createCanvas(3464, 3464);\n    for (var i = 0; i < img.height; i += bandHeight) {\n\n        if(random() < 0.25)\n        {\n            img.copy(img,\n                0, i, img.width, bandHeight,\n                random(-bandMisalign, bandMisalign), i + random(10, 25), img.width, bandHeight);\n        }\n    }\n    for (var i = 0; i < img.width; i += bandWidth) {\n\n        if (random() < 0.10) {\n            img.copy(img,\n                i, 0, bandWidth, img.height,\n                i + random(10, 25), random(-bandMisalign, bandMisalign), bandWidth, img.height);\n        }\n    }\n    var heightResized = width * img.height / img.width;\n    image(img, 0, 0, img.width, img.height, 0, 0, width, heightResized);\n\n    bandHeight = 10;\n    for (var i = 0; i < img.height; i += bandHeight) {\n        if (random() > 0.95) {\n            fill(random(pallete));\n            noStroke();\n            rect(0, i, img.width, bandHeight);\n        }\n    }\n    bandWidth = 15;\n    for (var i = 0; i < img.width; i += bandWidth) {\n        if (random() > 0.95) {\n            fill(random(pallete));\n            noStroke();\n            rect(i, 0, bandWidth, img.height);\n        }\n    }\n}"
    }


  },
  {
    "id": "A43",
    "title": "green_text_fall_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"green_text_fall_sketch",
      "extension":".js",
      "content":"var streams = [];\nvar fadeInterval = 1.6;\nvar symbolSize = 24;\n\nfunction setup() {\n    createCanvas(\n        window.innerWidth,\n        window.innerHeight\n    );\n    background(0);\n\n    var x = 0;\n    for (var i = 0; i <= width / symbolSize; i++) {\n        var stream = new Stream();\n        stream.generateSymbols(x, random(-2000, 0));\n        streams.push(stream);\n        x += symbolSize\n    }\n\n    textFont('Consolas');\n    textSize(symbolSize);\n}\n\nfunction draw() {\n    background(0, 150);\n    streams.forEach(function (stream) {\n        stream.render();\n    });\n}\n\nfunction Symbol(x, y, speed, first, opacity) {\n    this.x = x;\n    this.y = y;\n    this.value;\n\n    this.speed = speed;\n    this.first = first;\n    this.opacity = opacity;\n\n    this.switchInterval = round(random(2, 25));\n\n    this.setToRandomSymbol = function () {\n        var charType = round(random(0, 5));\n        if (frameCount % this.switchInterval == 0) {\n            if (charType > 1) {\n                // set it to Katakana\n                this.value = String.fromCharCode(\n                    0x30A0 + floor(random(0, 97))\n                );\n            } else {\n                // set it to numeric\n                this.value = floor(random(0, 10));\n            }\n        }\n    }\n\n    this.rain = function () {\n        this.y = (this.y >= height) ? 0 : this.y += this.speed;\n    }\n\n}\n\nfunction Stream() {\n    this.symbols = [];\n    this.totalSymbols = round(random(5, 35));\n    this.speed = random(5, 22);\n\n    this.generateSymbols = function (x, y) {\n        var opacity = 255;\n        var first = round(random(0, 4)) == 1;\n        for (var i = 0; i <= this.totalSymbols; i++) {\n            symbol = new Symbol(\n                x,\n                y,\n                this.speed,\n                first,\n                opacity\n            );\n            symbol.setToRandomSymbol();\n            this.symbols.push(symbol);\n            opacity -= (255 / this.totalSymbols) / fadeInterval;\n            y -= symbolSize;\n            first = false;\n        }\n    }\n\n    this.render = function () {\n        this.symbols.forEach(function (symbol) {\n            if (symbol.first) {\n                fill(140, 255, 170, symbol.opacity);\n            } else {\n                fill(0, 255, 70, symbol.opacity);\n            }\n            text(symbol.value, symbol.x, symbol.y);\n            symbol.rain();\n            symbol.setToRandomSymbol();\n        });\n    }\n}\n"
    }


  },
  {
    "id": "A44",
    "title": "heart_burst_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"heart_burst_sketch",
      "extension":".js",
      "content":"let kMax;\nlet step;\nlet n = 100; // number of blobs\nlet radius = 15; // diameter of the circle\nlet inter = 0.5; // difference between the sizes of two blobs\nlet maxNoise = 200;\n\nlet noiseProg = (x) => (x * x);\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n    colorMode(HSB, 1);\n    angleMode(DEGREES);\n    noFill();\n    noLoop();\n    kMax = random(0.6, 1.2);\n    step = 0.01;\n    noStroke();\n}\n\nfunction draw() {\n    background(0.6, 0.75, 0.25);\n    rotate(PI);\n    for (let i = n; i > 0; i--) {\n        let alpha = 1 - noiseProg(i / n);\n        //Change color of the heart here\n        fill((alpha / 5 + 0.3) % 1, 1, 1, alpha);\n        let size = radius + i * inter;\n        let k = kMax * sqrt(i / n);\n        let noisiness = maxNoise * noiseProg(i / n);\n        blob(size, width / 2, height / 2, k, i * step, noisiness);\n    }\n}\n\nfunction blob(size, xCenter, yCenter, k, t, noisiness) {\n    beginShape();\n    let angleStep = 360 / 500;\n    for (let theta = 360; theta > 0; theta -= angleStep) {\n        let r1, r2;\n        r1 = cos(theta) + 1;\n        r2 = sin(theta) + 1;\n        let r = size + noise(k * r1, k * r2, t) * noisiness;\n        let x = xCenter + 16* (r/10) * pow(sin(theta), 3);\n        let y = yCenter + (r/10) * (13 * cos(theta) - 5 * cos(2 * theta) - 2 * cos(3 * theta) - 4 * cos(4*theta));\n        curveVertex(x, y);\n    }\n    endShape(CLOSE);\n}"
    }

  },
  {
    "id": "A45",
    "title": "hypnotic_spheres_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"hypnotic_spheres_sketch",
      "extension":".js",
      "content":"const CYCLE = 100;\nlet tex;\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight, WEBGL);\n    let s = min(windowWidth, windowHeight);\n    tex = createGraphics(s * 2, s * 2);\n    tex.noFill();\n    tex.background(0);\n    texture(tex);\n    noStroke();\n}\n\nfunction draw() {\n    background(29, 53, 87);\n    orbitControl();\n    let fc = (frameCount % CYCLE) / CYCLE;\n    let step = (tex.width) / 20;\n    tex.background(29, 53, 87, 10);\n    tex.stroke(168, 218, 220);\n    tex.strokeWeight(step / 10);\n    for (let x = step * (- 3); x < tex.width + step * 3; x += step) {\n        tex.beginShape();\n        for (let y = 0; y <= tex.height; y += 10) {\n            let r = map(y, 0, tex.height, 0, TAU * 4) + fc * TAU;\n            tex.vertex(x + sin(r) * step * (1 + cos(fc * TAU) * 0.2), y);\n        }\n        tex.endShape();\n    }\n    rotateY(0.1);\n    rotateX(1);\n    sphere(min(width, height) * 0.3, 60, 30);\n}"
    }

  },
  {
    "id": "A46",
    "title": "lines_dots_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"lines_dots_sketch",
      "extension":".js",
      "content":"const particles = [];\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    const particlesLength = Math.min(Math.floor(window.innerWidth / 10), 100);\n    for(let i = 0; i < particlesLength; i++) {\n        particles.push(new Particle());\n    }\n}\n\nfunction draw(){\n    background(26);\n    particles.forEach((particle, idx) => {\n        particle.update();\n        particle.draw();\n        particle.checkParticles(particles.slice(idx));\n    });\n}\n\nclass Particle {\n    constructor() {\n        this.pos = createVector(random(width), random(height));\n        this.vel = createVector(random(-2, 2), random(-2, 2));\n        this.size = 5;\n    }\n\n    update() {\n        this.pos.add(this.vel);\n        this.edges();\n    }\n\n    draw() {\n        noStroke();\n        fill('rgba(255, 255, 255, 0.5)');\n        circle(this.pos.x, this.pos.y, this.size * 2);\n    }\n\n    edges() {\n        if (this.pos.x < 0 || this.pos.x > width) {\n            this.vel.x *= -1;\n        }\n\n        if (this.pos.y < 0 || this.pos.y > height) {\n            this.vel.y *= -1;\n        }\n    }\n    checkParticles(particles) {\n        particles.forEach(particle => {\n            const d = dist(this.pos.x, this.pos.y, particle.pos.x, particle.pos.y);\n            if (d < 120) {\n                const alpha = map(d, 0, 120, 0, 0.25)\n                stroke(`rgba(255, 255, 255, ${alpha})`);\n                line(this.pos.x, this.pos.y, particle.pos.x, particle.pos.y)\n            }\n        });\n    }\n}"
    }

  },
  {
    "id": "A47",
    "title": "lines_spheres_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"lines_spheres_sketch",
      "extension":".js",
      "content":"var constellation = [];\nvar n;\nvar d;\n\nfunction setup() {\n    // createCanvas(500, 500);\n    createCanvas(720, 720);\n    pixelDensity(1); // Set 1 because it's too slow on firefox\n    //pixelDensity(displayDensity());\n    n = 200;\n\n    for (var i = 0; i <= n; i++) {\n        constellation.push(new star());\n    }\n    strokeWeight(.75);\n    stroke('#00FFaF');\n}\n\nfunction draw() {\n\n    background('#000020');\n\n    for (var i = 0; i < constellation.length; i++) {\n        constellation[i].update();\n        for (var j = 0; j < constellation.length; j++) {\n            if (i > j) { // \"if (i > j)\" => to check one time distance between two stars\n                d = constellation[i].loc.dist(constellation[j].loc); // Distance between two stars\n                if (d <= width / 8) { // if d is less than width/10 px, we draw a line between the two stars\n                    line(constellation[i].loc.x, constellation[i].loc.y, constellation[j].loc.x, constellation[j].loc.y)\n                }\n            }\n        }\n    }\n\n}\n\nfunction star() {\n\n    this.a = random(5 * TAU); // \"5*TAU\" => render will be more homogeneous\n    this.r = random(width * .4, width * .25); // first position will looks like a donut\n    this.loc = createVector(width / 2 + sin(this.a) * this.r, height / 2 + cos(this.a) * this.r);\n    this.speed = createVector();\n    this.speed = p5.Vector.random2D();\n    //this.speed.random2D();\n    this.bam = createVector();\n    this.m;\n\n\n    this.update = function () {\n        this.bam = p5.Vector.random2D(); // movement of star will be a bit erractic\n        //this.bam.random2D();\n        this.bam.mult(0.45);\n        this.speed.add(this.bam);\n        // speed is done according distance between loc and the mouse :\n        this.m = constrain(map(dist(this.loc.x, this.loc.y, mouseX, mouseY), 0, width, 8, .05), .05, 8); // constrain => avoid returning \"not a number\"\n        this.speed.normalize().mult(this.m);\n\n        // No colision detection, instead loc is out of bound\n        // it reappears on the opposite side :\n        if (dist(this.loc.x, this.loc.y, width / 2, height / 2) > (width / 2) * 0.98) {\n            if (this.loc.x < width / 2) {\n                this.loc.x = width - this.loc.x - 4; // \"-4\" => avoid blinking stuff\n            } else if (this.loc.x > width / 2) {\n                this.loc.x = width - this.loc.x + 4; // \"+4\"  => avoid blinking stuff\n            }\n            if (this.loc.y < height / 2) {\n                this.loc.y = width - this.loc.y - 4;\n            } else if (this.loc.x > height / 2) {\n                this.loc.y = width - this.loc.y + 4;\n            }\n        }\n        this.loc = this.loc.add(this.speed);\n    } // End of update()\n} // End of class"
    }

  },
  {
    "id": "A48",
    "title": "Maze_sketch",
    "artist": "pratiksinghal48",
    "year": "2020",
    "repoUrl": "https://github.com/pratiksinghal48/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"Maze_sketch",
      "extension":".js",
      "content":"var cols, rows;\nvar w = 25;\nvar grid = [];\nvar stack = [];\nvar current;\n\nfunction setup()\n{\n    createCanvas(500,500);\n    cols = floor(width/w);\n    rows = floor(height/w);\n    //frameRate();\n    console.log(frameRate());\n\n    for(var j = 0; j < rows; j++)\n    {\n        for(var i = 0; i < cols; i++)\n        {\n            var cell = new Cell(i,j);\n            grid.push(cell);\n        }\n    }\n    current = grid[0];\n}\n\nfunction draw()\n{\n    background(51);\n    for(var i = 0; i < grid.length; i++)\n    {\n        grid[i].show();\n    }\n    current.visited = true;\n    current.highlight();\n    var next = current.getNeighbours();\n    if(next)\n    {\n        next.visited = true;\n        stack.push(current);\n        current.p = true;\n\n        removeWalls(current, next);\n\n        current = next;\n    }\n    else if(stack.length > 0)\n    {\n        current = stack.pop();\n        current.p = false;\n    }\n    else\n    {\n        console.log(\"Done\");\n        noLoop();\n        return;\n    }\n}\n\n\n\nfunction index(i, j)\n{\n    if(i< 0 || j < 0 || i > cols - 1 || j > rows - 1 )\n        return -1;\n\n    return i + j * cols;\n}\n\nfunction removeWalls(a, b)\n{\n    var d = a.i - b.i;\n    if(d === 1)\n    {\n        a.walls[3] = false;\n        b.walls[1] = false;\n    }else if(d === -1)\n    {\n        a.walls[1] = false;\n        b.walls[3] = false;\n    }\n    var c = a.j - b.j;\n    if(c === -1)\n    {\n        a.walls[2] = false;\n        b.walls[0] = false;\n    }else if(c === 1)\n    {\n        a.walls[0] = false;\n        b.walls[2] = false;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    }

  },
  {
    "id": "A49",
    "title": "move_particles_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"move_particles_sketch",
      "extension":".js",
      "content":"var particleQuantity = 2000;\n\n\nvar positionX = new Array(particleQuantity);\nvar positionY = new Array(particleQuantity);\nvar velocityX = new Array(particleQuantity).fill(0);\nvar velocityY = new Array(particleQuantity).fill(0);\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    frameRate(20);\n    stroke(224, 177, 203);\n    for (var particle = 1; particle < particleQuantity; particle++) {\n        positionX[particle] = random(0, width);\n        positionY[particle] = random(0, height);\n    }\n\n    positionX[0] = 0;\n    positionY[0] = 0; \n}\n\n\nfunction draw() {\n    background(35, 25, 66, 128);\n    velocityX[0] = velocityX[0] * 0.5 + (mouseX - positionX[0]) * 0.1;\n    velocityY[0] = velocityY[0] * 0.5 + (mouseY - positionY[0]) * 0.1;\n\n    positionX[0] += velocityX[0];\n    positionY[0] += velocityY[0];\n\n    for (var particle = 1; particle < particleQuantity; particle++) {\n        var whatever = 1024 / (sq(positionX[0] - positionX[particle]) + sq(positionY[0] - positionY[particle]));\n\n        velocityX[particle] = velocityX[particle] * 0.95 + (velocityX[0] - velocityX[particle]) * whatever;\n        velocityY[particle] = velocityY[particle] * 0.95 + (velocityY[0] - velocityY[particle]) * whatever;\n\n        positionX[particle] += velocityX[particle];\n        positionY[particle] += velocityY[particle];\n\n        if ((positionX[particle] < 0 && velocityX[particle] < 0) || (positionX[particle] > width && velocityX[particle] > 0)) {\n            velocityX[particle] = -velocityX[particle];\n        }\n\n        if ((positionY[particle] < 0 && velocityY[particle] < 0) || (positionY[particle] > height && velocityY[particle] > 0)) {\n            velocityY[particle] = -velocityY[particle];\n        }\n\n        ellipse(positionX[particle], positionY[particle], 3, 3);\n    }\n}\n\n\nfunction mousePressed() {\n    for (var particle = 1; particle < particleQuantity; particle++) {\n        positionX[particle] = random(0, width);\n        positionY[particle] = random(0, height);\n    }\n}"
    }

  },
  {
    "id": "A50",
    "title": "neural_networks_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"neural_networks_sketch",
      "extension":".js",
      "content":"let network = [];\nlet nLayers = 9;\n\nfunction setup() {\n    createCanvas(925, 500);\n    fill(250);\n    let x = 150;\n    let interLayer = (width-300)/(nLayers-3);\n    network.push([createVector(150-interLayer, height/2)]);\n    for(let i = 0; i < nLayers-2; i++)\n    {\n        let layer = [];\n        let nNodes = floor(random(5, 15));\n        let interNode = 20;\n        let y = height/2 - floor(nNodes/2)*interNode;\n\n        for(let j = 0; j < nNodes; j++){\n            layer.push(createVector(x, y));\n            y += interNode;\n        }\n        network.push(layer);\n        x += interLayer;\n    }\n    network.push([createVector(width-150+interLayer, height/2)]);\n}\n\nfunction draw() {\n    background(48, 52, 63);\n    for(let i = 0; i < nLayers-1; i++)\n    {\n        let l1 = network[i];\n        let l2 = network[i+1];\n        for(let node1 of l1)\n        {\n            circle(node1.x, node1.y, 5);\n            for(let node2 of l2)\n            {\n                let noice = noise(i, node1.y+node2.y, frameCount/100);\n\n                strokeWeight(0.6+noice);\n                stroke(7, 190, 184, noice*250);\n                line(node1.x, node1.y, node2.x, node2.y);\n            }\n        }\n    }\n\n    let lastNode = network[nLayers -1][0];\n    circle(lastNode.x, lastNode.y, 5);\n    noStroke();\n}\n"
    }

  },
  {
    "id": "A51",
    "title": "noise_stack_loop_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "random"], 
      "interaction": ["none"], 
      "outcome": ["visual", "static"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"noise_stack_loop_sketch",
      "extension":".js",
      "content":"let _aryObjects = [];\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    frameRate(30);\n    noStroke();\n    colorMode(HSB, 1);\n    let objectNum = 30;\n    let rMax = width / 1.3 * random(0.2, 1);\n    let yGap = height / objectNum / 1.5;\n    let divideNum = 16;\n    let noiseSeedRad = random(10);\n    let noiseSeedAng = random(10);\n    let noiseStepRad = 0.3;\n    let noiseStepAng = 0.02;\n    let noiseSpeedRad = 0.01;\n    let noiseSpeedAng = 0.03;\n    let noiseStepObj = 0.02;\n    let rOffset = -0.0;\n    let noiseSeedT = random(10);\n    let noiseSpeedT = 0.01;\n    for (let i = 0; i < objectNum; i++) {\n        let myArc = new Arc(rMax, i, objectNum, yGap,\n            divideNum, noiseSeedRad + i * noiseStepObj, noiseSeedAng + i * noiseStepObj, noiseSeedT + i * noiseStepObj,\n            noiseStepRad, noiseStepAng, noiseSpeedRad, noiseSpeedAng, noiseSpeedT, rOffset);\n        _aryObjects.push(myArc);\n    }\n}\n\nclass Arc {\n    constructor(rMax, obj_i, objectNum, yGap,\n        divideNum, noiseSeedRad, noiseSeedAng, noiseSeedT,\n        noiseStepRad, noiseStepAng, noiseSpeedRad, noiseSpeedAng, noiseSpeedT, rOffset) {\n        this.centX = 0;\n        this.centY = yGap * (objectNum - obj_i) - height / 3;\n        this.objectNum = objectNum;\n        this.rMax = rMax;\n        this.color = color(random(0, 1), 0.8, 1, .75);\n        this.obj_i = obj_i;\n        this.divideNum = divideNum;\n        this.noiseSeedRad = noiseSeedRad;\n        this.noiseSeedAng = noiseSeedAng;\n        this.noiseSeedT = noiseSeedT;\n        this.noiseStepRad = noiseStepRad;\n        this.noiseStepAng = noiseStepAng;\n        this.noiseSpeedRad = noiseSpeedRad;\n        this.noiseSpeedAng = noiseSpeedAng;\n        this.noiseSpeedT = noiseSpeedT;\n        this.rOffset = rOffset;\n    }\n    drawMe() {\n        this.noiseSeedRad += this.noiseSpeedRad;\n        this.noiseSeedAng += this.noiseSpeedAng;\n        this.noiseSeedT += this.noiseSpeedT;\n        fill(this.color);\n        drawingContext.shadowColor = color(0);\n        drawingContext.shadowBlur = width / 20;\n        drawingContext.shadowOffsetY = width / 32;\n        let sumNoiseVal = 0;\n        for (let i = 0; i < this.divideNum; i++) {\n            sumNoiseVal += noise(this.noiseSeedAng + i * this.noiseStepAng) * 3;\n        }\n        let currentNoiseVal = 0;\n        let d = 1;\n        let rx_0;\n        let ry_0;\n        let rx_last;\n        let ry_last;\n        beginShape();\n        for (let i = 0; i < this.divideNum + 3; i++) {\n            let tgt_i = i;\n            if (tgt_i >= this.divideNum) { tgt_i -= this.divideNum; }\n            currentNoiseVal += noise(this.noiseSeedAng + tgt_i * this.noiseStepAng) * 3;\n            let maxAng = 2 * PI * currentNoiseVal / sumNoiseVal + 2 * PI;\n            let rx = this.rMax * (noise(this.noiseSeedRad + tgt_i * this.noiseStepRad, this.noiseSeedT) + this.rOffset) ** d * cos(maxAng)/1.5;\n            let ry = this.rMax * (noise(this.noiseSeedRad + tgt_i * this.noiseStepRad, this.noiseSeedT) + this.rOffset) ** d * sin(maxAng)/1.5;\n            if (tgt_i == 0) {\n                rx_0 = rx;\n                ry_0 = ry;\n            } else if (tgt_i == this.divideNum - 2) {\n                rx_last = rx;\n                ry_last = ry;\n            } else if (tgt_i == this.divideNum - 1) {\n                rx = (rx_0 + rx_last) / 2;\n                ry = (ry_0 + ry_last) / 2;\n            }\n            curveVertex(this.centX + rx, this.centY + ry);\n        }\n        endShape();\n    }\n}\n\nfunction draw() {\n    background(0);\n    push();\n    translate(width / 2, height / 2);\n    for (let i = 0; i < _aryObjects.length; i++) {\n        _aryObjects[i].drawMe();\n    }\n    pop();\n}"
    }
  },
  {
    "id": "A52",
    "title": "noise_vortex_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"noise_vortex_sketch",
      "extension":".js",
      "content":"let R;\n\nlet num = 40;\nlet palette1 = [\"#09bc8a\", \"#9fa0c3\"];\nlet palette2 = [\"#75dddd\", \"#db7f8e\", \"#2f243a\"];\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n\n    noLoop();\n    angleMode(DEGREES);\n\n    R = max(width, height)*1.5;\n\n    noFill();\n}\n\nfunction draw() {\n    background(0);\n\n    blendMode(ADD);\n    push();\n\n    translate(width / 2, height / 2);\n\n    let c = color(random(palette1));\n    let csub = color(random(palette2));\n\n    for(let j = 0; j < num; j++)\n    {\n        let stwt = j < num / 2 ? 30 : 10;\n        c.setAlpha(10);\n        csub.setAlpha(40);\n        let stcol = j < num / 2 ? c : csub;\n\n        strokeWeight(stwt);\n        stroke(stcol);\n\n        let delta = 0.015;\n\n        beginShape();\n        for(let i = 0; i < R; i++)\n        {\n            let r = i;\n            let t = map(noise(i*delta, j*0.03), 0, 1, -360, 360);\n            let x = r * cos(t);\n            let y = r * sin(t);\n\n            vertex(x, y);\n        }\n        endShape();\n    }\n    pop();\n}"
    }

  },
  {
    "id": "A53",
    "title": "noise_wallpaper_1_shape2",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"noise_wallpaper_1_shape2",
      "extension":".js",
      "content":"// By Roni Kaufman\n\nlet kMax; // maximal value for the parameter \"k\" of the blobs\nlet step = 0.01; // difference in time between two consecutive blobs\nlet n = 100; // total number of blobs\nlet radius = 0; // radius of the base circle\nlet inter = 0.05; // difference of base radii of two consecutive blobs\nlet maxNoise = 700; // maximal value for the parameter \"noisiness\" for the blobs\n\n//let noiseProg = (x) => (x);\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n    colorMode(HSB, 1);\n    angleMode(DEGREES);\n    noFill();\n    //noLoop();\n    kMax = random(0.6, 1.0);\n    noStroke();\n}\n\nfunction draw() {\n    background(0);\n    let t = frameCount / 100;\n    for (let i = n; i > 0; i--) {\n        let alpha = 1-(i / n);\n        fill(noise((alpha+0.75)%1), 1, 1, alpha);\n        let size = radius + i * inter;\n        let k = kMax * sqrt(i / n);\n        let noisiness = maxNoise * (i / n);\n        blob(size, width / 2, height / 2, k, t - i * step, noisiness);\n    }\n}\n\n// Creates and draws a blob\n// size is the radius (before noise) of the base circle\n// (xCenter, yCenter) is the position of the center of the blob\n// k is the tightness of the blob (0 = perfect circle, higher = more spiky)\n// t is the time\n// noisiness is the magnitude of the noise (i.e. how far it streches out)\nfunction blob(size, xCenter, yCenter, k, t, noisiness) {\n    beginShape();\n    let angleStep = 360 / 10;\n    for (let theta = 0; theta <= 360 + 2 * angleStep; theta += angleStep) {\n        let r1, r2;\n        r1 = cos(theta) + 1;\n        r2 = sin(theta) + 1;\n        let r = size + noise(k * r1, k * r2, t) * noisiness;\n        let x = xCenter + r * cos(theta);\n        let y = yCenter + r * sin(theta);\n        curveVertex(x, y);\n    }\n    endShape();\n}"
    }

  },
  {
    "id": "A54",
    "title": "noise_wallpaper_2_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"noise_wallpaper_2_sketch",
      "extension":".js",
      "content":"function setup(){\n    createCanvas(windowWidth, windowHeight);\n    background('black');\n    noLoop();\n}\n\nfunction draw(){\n    noStroke();\n    for(var i = 0; i < 300; i++){\n        var x = random(width/5, width*4/5);\n        var y = random(height/5, height*4/5);\n       fill (noise(0.1)*57, noise(0.5)*255, noise(0.2)*20, 10);\n        ellipse(x, y, 50);\n        fill(57, 255, 20, 20);\n        for(var j = 0; j < 1000; j++){\n            ellipse(x, y, 2);\n            x += 5*(noise(x/100, y/100, i/100)-0.5);\n            y += 5*(noise(y/100, i/100, x/100)-0.5);\n        }\n    }\n    noFill();\n    strok(57,255,  20);\n    rect(50, 50 , width-1-100, height-1-100);\n}"
    }

  },
  {
    "id": "A55",
    "title": "overlapShapes_random_sketch",
    "artist": "HouCoder",
    "year": "2020",
    "repoUrl": "https://github.com/HouCoder/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"overlapShapes_random_sketch",
      "extension":".js",
      "content":"let x, y, i;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  colorMode(HSB, 100, 100, 100);\n}\n\nfunction draw() {\n  noLoop();\n    background(0, 0, 0, 30);\n\n  for (y = 0; y < height - 20; y += 100) {\n    for (x = 0; x < width - 20; x += 100) {\n      for (i = 0; i < 15; i++) {\n\n        fill(random(0, 100), 100, 100, random(0.8));\n        noStroke();\n        triangle(x + random(60), y + random(60), x + random(60), y + random(60), x + random(60), y + random(60));\n        ellipse(x + random(70), y + random(70), i, i);\n      }\n    }\n  }\n}\n\n// function mousePressed() {\n\n// }"
    }

  },
  {
    "id": "A56",
    "title": "paint_strokes_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"paint_strokes_sketch",
      "extension":".js",
      "content":"let colors = \"e6e1c5-d4cb92-395c6b-80a4ed-bcd3f2-f24-fff-52489c-4062bb-59c3c3-ebebeb-f45b69-0c090d-e01a4f-f15946-f9c22e-53b3cb\".split(\"-\").map(a => \"#\" + a)\nlet overallTexture\nclass Particle {\n    constructor(args) {\n        let def = {\n            p: createVector(0, 0),\n            v: createVector(0, 0),\n            a: createVector(0, 0),\n            r: 10,\n            dp: random(0.93, 0.99),\n            angMult: random(10, 50),\n            color: random(colors)\n        }\n        Object.assign(def, args)\n        Object.assign(this, def)\n    }\n    draw() {\n        // strokeWeight(3)\n        mainGraphics.push()\n        mainGraphics.translate(this.p.x, this.p.y)\n        mainGraphics.fill(this.color)\n        mainGraphics.noStroke()\n        // stroke(0,100)\n        mainGraphics.ellipse(0, 0, this.r)\n        mainGraphics.pop()\n    }\n    update() {\n        this.p.add(this.v)\n        this.v.add(this.a)\n        let delta = createVector(this.p.x - width / 2, this.p.y - height / 2)\n        let ang = delta.heading()\n        let rr = delta.mag()\n\n        this.v.x += -sin(ang * this.angMult + rr / 5) / 15 + cos(rr / 10) / 10\n        this.v.y += -cos(ang * this.angMult + rr / 5) / 15 + sin(rr / 10) / 10\n        this.a.x = (noise(this.p.x, this.p.y, 5) - 0.5) * 1.1\n        this.a.y = (noise(this.p.x, this.p.y, 5000) - 0.5) * 1.1\n\n        this.v.mult(0.95)\n        this.r *= this.dp\n\n    }\n}\n\nlet particles = []\nlet textureGraphics\nlet mainGraphics\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n\n    overAllTexture = createGraphics(width, height)\n    mainGraphics = createGraphics(width, height)\n    overAllTexture.loadPixels()\n\n    // noStroke()\n    for (var i = 0; i < width + 50; i++) {\n        for (var o = 0; o < height + 50; o++) {\n            overAllTexture.set(i, o, color(150, noise(i / 10, i * o / 300) * random([0, 50, 100])))\n        }\n    }\n    overAllTexture.updatePixels()\n\n    background(100);\n    for (var i = 0; i < width; i += 30) {\n        for (var o = 0; o < height; o += 30) {\n            particles.push(new Particle({\n                p: createVector(i, o),\n                v: createVector(noise(i / 10) * 10 - 5, noise(o / 10) * 10 - 5),\n                r: random(200)\n            }))\n        }\n    }\n    background(0)\n}\n\nfunction draw() {\n    // \n    particles.forEach(p => p.draw())\n    particles.forEach(p => p.update())\n    image(mainGraphics, 0, 0)\n\n    push()\n    blendMode(ADD)\n    image(overAllTexture, 0, 0)\n    pop()\n    // ellipse(mouseX, mouseY, 20, 20);\n}"
    }

  },
  {
    "id": "A57",
    "title": "particle_attraction_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"particle_attraction_sketch",
      "extension":".js",
      "content":"var mass = [];\nvar positionX = [];\nvar velocityX = [];\nvar positionY = [];\nvar velocityY = [];\n\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    noStroke();\n    fill(255, 165, 171, 192);\n}\n\nfunction draw() {\n    background(69, 9, 32);\n    for(var particleA = 0; particleA < mass.length; particleA++) {\n        var accelerationX = 0, accelerationY = 0;\n        \n        for(var particleB = 0; particleB < mass.length; particleB++){\n            if(particleA != particleB){\n                var distanceX = positionX[particleB] - positionX[particleA];\n                var distanceY = positionY[particleB] - positionY[particleA];\n                var distance = sqrt(distanceX*distanceX + distanceY*distanceY);\n                if(distance < 1)\n                    distance = 1;\n                var force = (distance - 320)*mass[particleB]/distance;\n                accelerationX += force*distanceX;\n                accelerationY += force*distanceY;\n            }\n        }\n        velocityY[particleA] = velocityY[particleA]*0.99 + accelerationY*mass[particleA];\n        velocityX[particleA] = velocityX[particleA]*0.99 + accelerationX*mass[particleA];\n    }\n    for(var particle = 0; particle < mass.length; particle++){\n        positionX[particle] += velocityX[particle];\n        positionY[particle] += velocityY[particle];\n        ellipse(positionX[particle], positionY[particle], mass[particle]*1000, mass[particle]*1000);\n    }\n}\n\nfunction addParticles() {\n    mass.push(random(0.0025, 0.025));\n    positionX.push(mouseX);\n    positionY.push(mouseY);\n    velocityX.push(0);\n    velocityY.push(0);\n}\n\nfunction mouseClicked() {\n    addParticles();\n}\n \nfunction mouseDragged() {\n    addParticles();\n}"
    }

  },
  {
    "id": "A58",
    "title": "perlinNoise2D_sketch",
    "artist": "HouCoder",
    "year": "2020",
    "repoUrl": "https://github.com/HouCoder/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image"], 
      "interaction": ["none"],
       "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"perlinNoise2D_sketch",
      "extension":".js",
      "content":"let start = 0; // move noise horizontally\nlet yoff = 0;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  background(30);\n\n}\n\nfunction draw() {\n  smooth();\n  stroke(142, 169, 237, 50);\n  noFill();\n\n  beginShape();\n\n  let xoff = start;\n  for (let x = 0; x < width; x += 10) {\n    // 2D noise changes y position as well\n    let y = map(noise(xoff, yoff), 0, 1, 120, height - 120);\n\n    vertex(x, y);\n    xoff += 0.05;\n\n  }\n  yoff += 0.008;\n\n  endShape();\n\n  // start+=0.001; move noise horizontally\n\n  if (yoff > 2.5) {\n    noLoop();\n  }\n}"
    }

  },
  {
    "id": "A59",
    "title": "pixel_rain_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"pixel_rain_sketch",
      "extension":".js",
      "content": "chains = [];\n\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    angleMode(DEGREES);\n    background(0);\n\n    let x = width / 2;\n    let y = height / 4;\n\n    let r = 50;\n\n    for (let theta = -180; theta <= 0; theta += 6) {\n        chains.push(new Rain(x + r * cos(theta), y + r * sin(theta), random(30, 40), random(3, 5), random(100, 200), 150, 1));\n    }\n\n    r = 30;\n\n    for (let theta = -180; theta <= 0; theta += 6) {\n        chains.push(new Rain(x + r * cos(theta), y + r * sin(theta), random(20, 30), random(6, 7), random(200, 250), 255, -1));\n    }\n\n    y = 5 * height / 8;\n    r = 50;\n\n    for (let theta = 180; theta >= 0; theta -= 6) {\n        chains.push(new Rain(x + r * cos(theta), y + r * sin(theta), random(30, 40), random(3, 5), random(100, 200), 150, -1));\n    }\n\n    r = 30;\n\n    for (let theta = 180; theta >= 0; theta -= 6) {\n        chains.push(new Rain(x + r * cos(theta), y + r * sin(theta), random(20, 30), random(6, 7), random(200, 250), 255, 1));\n    }\n\n    for (let chain of chains) {\n        chain.dripple();\n    }\n\n}\n\nfunction draw() {\n    noLoop();\n}\n\nclass Rain {\n    constructor(x, y, size, radius, alpha, grey, direction) {\n        this.x = x;\n        this.y = y\n        this.size = size;\n        this.radius = radius;\n        this.alpha = alpha;\n        this.grey = grey;\n        this.direction = direction;\n    }\n\n    dripple() {\n        let a = this.alpha;\n        let c = this.grey;\n        a = (this.alpha - 50) / this.size;\n        c = (this.grey - 50) / this.size;\n        for (let i = 0; i < this.size; i++) {\n            fill(this.grey, this.alpha)\n            ellipse(this.x, this.y, this.radius);\n            this.radius -= 0.03;\n            if (this.direction == -1) this.y += this.radius;\n            else this.y -= this.radius;\n            this.grey -= c;\n            this.alpha -= a;\n        }\n    }\n}   "
    }

  },
  {
    "id": "A60",
    "title": "portfolioWeb_sketch",
    "artist": "HouCoder",
    "year": "2020",
    "repoUrl": "https://github.com/HouCoder/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["human_interaction"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"portfolioWeb_sketch",
      "extension":".js",
      "content":"var particles = [];\nvar bg\nconst COL = createCols(\"https://coolors.co/app/f1e7b6-400082-fe346e-f3c623-06aed5\");\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  pixelDensity(1);\n  background(255);\n  bg = createGraphics(width, height);\n  bg.background(255, 20);\n  bg.noStroke();\n  for (let i = 0; i < 300000; i++) {\n    let x = random(width);\n    let y = random(height);\n    let s = noise(x * 0.01, y * 0.01) * 2;\n    bg.fill(240, 50);\n    bg.rect(x, y, s, s);\n  }\n}\n\nfunction draw() {\n  var newParticles = [];\n  for (var i = 0; i < particles.length; i++) {\n    particles[i].update();\n    particles[i].wallBound();\n    particles[i].display();\n    if (particles[i].radius > 0) {\n      newParticles.push(particles[i]);\n    }\n  }\n  particles = newParticles;\n  image(bg, 0, 0);\n}\n\nfunction mouseMoved() {\n  var x = mouseX;\n  var y = mouseY;\n  var vx = (winMouseX - pwinMouseX) * 0.2;\n  var vy = (winMouseY - pwinMouseY) * 0.2;\n  if ((x > 50 && x < width - 50) && (y > 50 && y < height - 50)) {\n    particles.push(new Particle(x, y, vx, vy));\n  }\n}\n\nfunction touchMoved() {\n  var x = mouseX;\n  var y = mouseY;\n  var vx = (winMouseX - pwinMouseX) * 0.2;\n  var vy = (winMouseY - pwinMouseY) * 0.2;\n  if ((x > 50 && x < width - 50) && (y > 50 && y < height - 50)) {\n    particles.push(new Particle(x, y, vx, vy));\n  }\n}\n\nvar Particle = function(x, y, vx, vy) {\n  this.position = createVector(x, y);\n  this.velocity = createVector(vx, vy);\n  this.friction = 0.009;\n  this.fcolor = color(COL[int(random(COL.length))]);\n  this.radius = random(10, 50);\n}\n\nParticle.prototype.update = function() {\n  this.velocity = this.velocity.mult(1 - this.friction);\n  this.position = this.position.add(this.velocity);\n  this.radius -= 0.1;\n}\n\nParticle.prototype.wallThrough = function() {\n  if (this.position.x >= width) {\n    this.position.x = 0;\n  }\n  if (this.position.x <= 0) {\n    this.position.x = width;\n  }\n  if (this.position.y >= height) {\n    this.position.y = 0;\n  }\n  if (this.position.y <= 0) {\n    this.position.y = height;\n  }\n}\n\nParticle.prototype.wallBound = function() {\n  if ((this.position.x >= width - this.radius) || (this.position.x <= this.radius)) {\n    this.velocity.x = -this.velocity.x;\n  } else if ((this.position.y >= height - this.radius) || (this.position.y <= this.radius)) {\n    this.velocity.y = -this.velocity.y;\n  } else {\n    return;\n  }\n}\n\nParticle.prototype.display = function() {\n  push();\n  translate(this.position.x, this.position.y);\n  noStroke();\n  fill(this.fcolor);\n  ellipse(0, 0, 2 * this.radius, 2 * this.radius);\n  pop();\n}\n\nfunction createCols(_url) {\n  let slash_index = _url.lastIndexOf('/');\n  let pallate_str = _url.slice(slash_index + 1);\n  let arr = pallate_str.split('-');\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = '#' + arr[i];\n  }\n  return arr;\n}"
    }
  },
  {
    "id": "A61",
    "title": "quadtree_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"quadtree_sketch",
      "extension":".js",
      "content":"function setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    w = min(width, height);\n    h = w/2;\n\n    noStroke();\n    colorMode(HSB);\n    rectMode(CENTER);\n}\n\nfunction draw() {\n    translate(width/2, height/2);\n    background(240, 180, 30);\n    drawRect(h, 0, 0);\n}\n\nfunction drawRect(size, x, y) {\n    if (size / h < abs(noise(x / h + frameCount / 200, y / h + frameCount / 100, mag(x,y)/w) - 0.46)) {\n        fill(size, w, w);\n        rect(x, y, size, size);\n    }\n    else {\n        size = size / 2;\n        if (size > 1) {\n            drawRect(size, x - size, y - size);\n            drawRect(size, x + size, y + size);\n            drawRect(size, x - size, y + size);\n            drawRect(size, x + size, y - size);\n        }\n    }\n\n    \n}"
    }

    
  },
  {
    "id": "A62",
    "title": "random_circle_no_overlap_sketch",
    "artist": "HouCoder",
    "year": "2020",
    "repoUrl": "https://github.com/HouCoder/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "static"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"random_circle_no_overlap_sketch",
      "extension":".js",
      "content":"let circles = [];\n// const COL = createCols(\"https://coolors.co/ffcdb2-ffb4a2-e5989b-b5838d-6d6875\");\n\nconst COL = createCols(\"https://coolors.co/1c2c4a-36558f-f9dc5c-ff6b6b-2a91db-5aa9e6-7fc8f8\");\n\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  background(255);\n\n  // Lets make sure we don't get stuck in infinite loop\n  let protection = 0;\n  // Try to get to 500\n  while (circles.length < 1500) {\n    // js object, pick a random circle\n    circle = {\n      x: random(width),\n      y: random(height),\n      r: random(6, 36)\n    };\n\n    // Does it overlap any previous circles?\n    let overlapping = false;\n    for (j = 0; j < circles.length; j++) {\n      let other = circles[j];\n      let d = dist(circle.x, circle.y, other.x, other.y);\n      if (d < circle.r + other.r) {\n        overlapping = true;\n      }\n    }\n\n    // if it's not overlapping then add to array\n    if (!overlapping) {\n      circles.push(circle);\n    }\n\n    // do not stuck\n    protection++;\n    if (protection > 8000) {\n      break;\n    }\n  }\n\n}\n\nfunction draw(){\n    // Draw all the circles\n  for (i = 0; i < circles.length; i++) {\n    noStroke();\n  fill(COL[int(random(COL.length))]);\n    ellipse(circles[i].x, circles[i].y, circles[i].r * 2, circles[i].r * 2);\n  }\n  noLoop();\n}\n\nfunction createCols(_url){\n  let slash_index = _url.lastIndexOf('/');\n  let pallate_str = _url.slice(slash_index + 1);\n  let arr = pallate_str.split('-');\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = '#' + arr[i];\n  }\n  return arr;\n}"
    }

    
  },
  {
    "id": "A63",
    "title": "random_collage_filters_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["processed_image","synthesized_image"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"random_collage_filters_sketch",
      "extension":".js",
      "content":"let imgs = [];\nlet img_num = 50;\nlet scl = 10;\nlet w, h;\nlet offset, margin;\nlet ratio = 0.25;\nlet graphics;\n\nfunction preload() {\n    w = int(300 / 2.54 * 72 / scl);\n    h = int(300 / 2.54 * 72 / scl);\n\n    for(let i = 0; i < img_num; i++) {\n        let img = loadImage(\"https://loremflickr.com/\" + w + \"/\" + h + \"/japan/?random=\" + i, \n        function() {imgs.push(img);});\n    }\n}\n\nfunction setup() {\n    createCanvas(w, h);\n    colorMode(HSB, 360, 100, 100, 100);\n    angleMode(DEGREES);\n\n    graphics = createGraphics(width, height);\n    graphics.colorMode(HSB, 360, 100, 100, 100);\n    graphics.angleMode(DEGREES)\n\n    offset = width / 50;\n    margin = offset / 1.5;\n}\n\n\nfunction draw() {\n    background(0, 0, 95);\n\n    graphics.clear();\n\n    let ySep = int(random(1, 6));\n    let yRowHeight = (height - offset * 2 - margin*(ySep -1));\n\n    let ySepArr = [];\n    let ySepSum = 0;\n    for(let i = 0; i < ySep; i++) {\n        let value = random([1, 5]);\n        ySepArr.push(value);\n        ySepSum += value;\n    }\n\n    for(let i = 0; i < ySep; i++) {\n        ySepArr[i] /= ySepSum;\n    }\n\n\n    ySepSum = 0;\n    for(let i = 0; i < ySepArr.length; i++)\n    {\n        let y = offset + i*margin + ySepSum*yRowHeight;\n\n        let h = max(int(ySepArr[i]*yRowHeight), 1);\n\n        let xSep = int(random(1, 6));\n\n        let xColWidth = (width - offset*2 - margin*(xSep -1));\n        let xSepArr = [];\n        let xSepSum = 0;\n\n        for (let i = 0; i < xSep; i++) {\n            let value = random(1);\n            xSepArr.push(value);\n            xSepSum += value;\n        }\n        for (let i = 0; i < xSep; i++) {\n            xSepArr[i] /= xSepSum;\n        }\n        xSepSum = 0;\n\n        for(let j = 0; j < xSepArr.length; j++) {\n            let x = offset + xSepSum * xColWidth + j * margin;\n            let w = max(int(xSepArr[j] * xColWidth), 1);\n\n            let img = random(imgs);\n\n            let img_trim = img.get(random(img.width - w), random(img.height - h), w, h);\n\n            if(min(w, h) > 0)\n            {\n                strokeWeight(0);\n                rect(x, y, w, h);\n                graphics.image(img_trim, x, y, w, h);\n            }\n            xSepSum += xSepArr[j];\n        }\n        ySepSum += ySepArr[i];\n    }\n    graphics.filter(POSTERIZE, 6);\n    // graphics.filter(THRESHOLD, ratio, 1-ratio);\n    // graphics.filter(INVERT);\n    push();\n    image(graphics, 0, 0);\n    pop();\n\n    frameRate(.5);\n}\n\n"
    }
    
  },
  {
    "id": "A64",
    "title": "rorschach_mask_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["processed_image", "synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","static"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"rorschach_mask_sketch",
      "extension":".js",
      "content":"\nlet noiseBackground;\n\nlet img;\n\nfunction preload() {\n    img = loadImage('mask.jpg');\n}\n\nfunction setup() {\n    createCanvas(window.innerHeight, window.innerHeight);\n\n    fill(10, 200);\n\n    noStroke();\n    createNoiseBackground();\n}\n\nfunction draw() {\n    background(206, 212, 218, 50);\n    image(noiseBackground, 0, 0);\n    // image(img, width/2, 0);\n\n    let alpha = 200;\n    let t = frameCount / 200;\n    for (let x = 0; x < width; x += 4) {\n        for (let y = 0; y < height; y += 4) {\n            let nse;\n            if (x < width / 2) {\n                nse = noise(x / alpha, y / alpha, t);\n            } else {\n                nse = noise((width - x) / alpha, y / alpha, t);\n            }\n            if (nse < 0.4) {\n                circle(x, y, 8);\n            }\n        }\n    }\n}\n\nfunction createNoiseBackground() {\n    noiseBackground = createGraphics(width, height);\n    noiseBackground.noStroke();\n\n    for (let i = 0; i < 10000; i++) {\n        noiseBackground.fill(random(180, 230), 5);\n        noiseBackground.ellipse(random(width), random(height), random(10), random(2));\n    }\n}"
    }

    
  },
  {
    "id": "A65",
    "title": "sine_cosine_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]


    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"sine_cosine_sketch",
      "extension":".js",
      "content":"var nTiles = 10;\nvar nFrames = 128;\nvar phase = 0.0;\nvar phaseInc = 1.0/nFrames;\n\n\nfunction drawWave(w, freq, amp, phase)\n{\n    push();\n    beginShape();\n    for (var x = -w / 2.0; x < w / 2.0 + 1; x++) {\n        vertex(x, sin(x / w * TAU * freq + phase) * amp);\n    }\n    endShape();\n    pop();\n}\n\nfunction setup() {\n    createCanvas(500, 500);\n    noFill();\n    seed = random(10000);\n}\n\nfunction draw() {\n    background(16);\n    resetMatrix();\n    randomSeed(seed);\n    noiseSeed(seed);\n\n\n    var w = width / nTiles;\n    var amp = w;\n    var nInc = 0.25;\n\n    var thisWidth = 400;\n    var thisHeight = 400;\n    var thisScale = thisWidth / width;\n    var t = (width-thisWidth) / 2.0;\n    var sw = w / 2.0 * thisScale;\n\n    translate(t + sw, t + sw);\n\n    for (var y = 0; y < nTiles; y++) {\n        var yPos = y / nTiles * thisHeight;\n        for (var x = 0; x < nTiles; x++) {\n            push();\n            var n = noise(x * nInc, (y + 1000) * nInc);  // Add noise to phase offset\n            var xPos = x / nTiles * thisWidth;\n\n            // Move to where sine will be drawn on screen\n            translate(xPos, yPos);\n\n            // Rotate approximately half of the sines\n            if (random() < 0.5) {\n                rotate(HALF_PI);\n            }\n\n            // Reverse direction for approximately half of the sines\n            var thisPhase = phase;\n            if (random() < 0.5) {\n                thisPhase = 1.0 - thisPhase;\n            }\n\n            // Select between cyan and magents\n            if (random() < 0.5) {\n                stroke(64, 255, 255);\n            } else {\n                stroke(248, 64, 248);\n            }\n\n            // Select frequency / period of sine\n            var freq = pow(2, random(5));\n\n            // Draw the wave\n            drawWave(w * 0.5, freq, amp * n * thisScale * 0.5, n * TAU + thisPhase * TAU);\n\n            pop();\n        }\n    }\n\n    // Update phasor\n    phase += phaseInc;\n}"
    }
    
  },
  {
    "id": "A66",
    "title": "single_blol_template_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"single_blol_template_sketch",
      "extension":".js",
      "content":"let kMax;\nlet step;\nlet n = 200; // number of blobs\nlet radius = 50; // diameter of the circle\nlet inter = 0.05; // difference between the sizes of two blobs\nlet maxNoise = 352;\nlet i = 200;\nlet counter = 0;\n\nlet noiseProg = (x) => (x*x);\n\nfunction setup() {\n    createCanvas(windowWidth, windowHeight);\n    colorMode(HSB, 360, 100, 100, 1);\n    angleMode(DEGREES);\n    background(0, 0, 100, 1);\n\n    noFill();\n    kMax = 1.5;\n    step = 0.01;\n    noStroke();\n}\n\nfunction draw() {\n\n    let t = frameCount/400;\n    stroke(360, 100, 100, 0.05);\n    strokeWeight(1.5);\n    let k = kMax * sqrt(i / n);\n    let noisiness = maxNoise * noiseProg(i / n);\n    blob(radius + i*inter, width / 2, height / 2, k, i*step + t, noisiness);\n\n    i -= random(0.1);\n    counter++;\n    if(counter > 4*n) noLoop();\n}\n\nfunction blob(size, xCenter, yCenter, k, t, noisiness) {\n    beginShape();\n    let angleStep = 360 / 500;\n    for (let theta = 360; theta > 0; theta -= angleStep) {\n        let r1, r2;\n        r1 = cos(theta) + 1;\n        r2 = sin(theta) + 1;\n        let r = size + noise(k * r1, k * r2, t) * noisiness;\n        let x = xCenter + r*cos(theta);\n        let y = yCenter + r*sin(theta);\n        curveVertex(x, y);\n    }\n    endShape(CLOSE);\n}"
      }
    
  },
  {
    "id": "A67",
    "title": "snowfall_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"snowfall_sketch",
      "extension":".js",
      "content":"let snowflakes = [];\n\n\nfunction setup() {\n    createCanvas(400, 600);\n    fill(240);\n    noStroke();\n}\n\nfunction draw(){\n    background(34, 0, 51);\n    let t = frameCount/60;\n    for(var i = 0; i < random(5); i++){\n        snowflakes.push(new snowflake());\n    }\n    for(let flake of snowflakes){\n        flake.update(t);\n        flake.display();\n    }\n}\n\n\n\nfunction snowflake(){\n    this.posX = 0;\n    this.posY = random(-50, 0);\n    this.initialAngle = random(0, 2*PI);\n    this.size = random(2, 5);\n    this.radius = sqrt(random(pow(width/2, 2)));\n    this.update = function(time){\n        let w = 0.6; //Angular velocity\n        let angle = w*time + this.initialAngle;\n        this.posX = width/2 + this.radius * sin(angle);\n        this.posY += pow(this.size, 0.5);\n        if(this.posY > height){\n            let index = snowflakes.indexOf(this);\n            snowflakes.splice(index, 1);\n        }\n    };\n    this.display = function() {\n        ellipse(this.posX, this.posY, this.size);\n    };\n}"
      }
  },
  {
    "id": "A68",
    "title": "star_sketch",
    "artist": "HouCoder",
    "year": "2020",
    "repoUrl": "https://github.com/HouCoder/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"star_sketch",
      "extension":".js",
      "content":"function setup() {\n  createCanvas(windowWidth, windowHeight);\n\n\n}\n\nfunction draw() {\n  blendMode(BLEND);\n  background(255);\n  blendMode(MULTIPLY);\n\n  translate(width / 2, height / 2);\n  fill(0,150,240);\n  star(5);\n  fill(240,0,240);\n  star(-5);\n\n}\n\nfunction star(cNum){\n   push();\n  beginShape();\n  let yoff = 0;\n  for (let a = 0; a < TWO_PI; a += 0.01) {\n      let xoff = 0;\n    let offset = map(sin(a*cNum+frameCount*0.05), -1, 1, -10, 50);\n    let r = 160+offset;\n    let x = r*cos(a);\n    let y = r*sin(a);\n    noStroke();\n   vertex(x,y);\n    xoff += 0.1;\n  }\n  endShape();\n  pop();\n  yoff += 0.1;\n}"
    }

  },
  {
    "id": "A69",
    "title": "surf_waves_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"surf_waves_sketch",
      "extension":".js",
      "content":"let x = 90.0;\nlet speed = 1.0;\nlet radius = 4.0;\nlet angle = 0.0;\nlet h = 4;\n\nfunction setup(){\n    createCanvas(window.innerWidth, window.innerHeight);\n    smooth();\n    noStroke();\n\n    background(18, 10, 143)\n}\n\nfunction draw() {\n    fill(115, 194, 251, 10);\n    stroke(115, 194, 251, 60);\n    angle = angle - 0.01;\n\n    translate(x, height/h); //set the y coordinate of the circle\n    rotate(angle);\n\n    triangle(-50, -50, -50, -50, 30, 30); //outer white\n    triangle(-50, -50, -50, -50, 90, 30); //inner white\n    triangle(-50, -0, -20, -20, 110, 2);  //black\n\n\n    x = x + speed;\n    if (x > width + radius) {\n        x = - radius;\n    }\n    h-=0.0008;\n    if(h<=1-2)\n        noLoop();\n}"
      }


  },
  {
    "id": "A70",
    "title": "tangent_strokes_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"tangent_strokes_sketch",
      "extension":".js",
      "content":"let particles = [];\nlet alpha;\nlet colors;\n\nlet palettes = [[\"#DCAFD0\", \"#E5998D\", \"#189A8A\", \"#5E418B\", \"#E3DB52\", \"#7798DD\"], [\"#10111C\", \"#23AECC\", \"#ECE1B4\", \"#CC3016\", \"#F2C96E\", \"#178FA6\"], ['#000090', '#0D809C', '#FFC200', '#D63826', '#FF7400', '#0F4155', '#5399A1', '#8CA96B', '#FF2600', '#EFAC55', '#668065', '#DBE5EC', '#336B87', '#2A3132', '#E94D35'], [\"#072ac8\", \"#1e96fc\", \"#a2d6f9\", \"#fcf300\", \"#ffc600\"], [\"#ffdb4d\", \"#f54556\", \"#477bf5\", \"#ff9640\", \"#4ebbf5\", \"#fe84fe\", \"#ffffff\"], [\"#FFFFFF\", \"#E60011\", \"#FECF00\"], [\"#FFFFFF\", \"#008ADF\", \"#FDDF03\", \"#FF015C\"]];\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    colorMode(HSB, 100);\n    noStroke();\n    background(\"#1D1A15\");\n    updateParticles();\n    alpha = random(500, 1000);\n}\n\nfunction draw() {\n    for(let p of particles) {\n        p.draw();\n        p.move();\n    }\n}\n\nfunction updateParticles() {\n    let colors = random(palettes);\n    particles = [];\n    let r = 1;\n    let n = 500;\n    for(let i = 0; i < n; i++) {\n        let theta = map(i, 0, n, -PI, PI);\n        let x_ = width/2 + r*cos(theta);\n        let y_ = height/2 + r*sin(theta);\n        let s_ = 2;\n        let c_ = random(colors);\n        particles.push(new Particle(x_, y_, s_, c_, i));\n    }\n}\n\nfunction Particle(x_, y_, s_, c_, i_) {\n    this.x = x_;\n    this.y = y_;\n    this.size = s_;\n    this.c = c_;\n\n    this.alpha = 100;\n    this.dist = 1;\n    this.offset = i_;\n\n\n    this.move = function () {\n        let theta = atan2(this.y-height/2, this.x-width/2) + frameCount/alpha + this.offset;\n        let v = p5.Vector.fromAngle(theta, this.dist);\n        this.x += v.x;\n        this.y += v.y;\n\n    }\n\n    this.draw = function() {\n        fill(this.c);\n        circle(this.x, this.y, this.size);\n    }\n}"
    }

  },
  {
    "id": "A71",
    "title": "tunnel_vision_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"tunnel_vision_sketch",
      "extension":".js",
      "content":"m = 0;\nC = 0;\n\n\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    background(0);\n    rectMode(CENTER);\n    noFill();\n    colorMode(HSB, 255);\n}\n\n\nfunction draw() {\n    background(0);\n    C+=0.2;\n    x = width/2;\n    y = height/2;\n    alpha = 255\n    for(let i = 0; i < 100; i++)\n    {\n        r = noise((i + C)*0.05)*TAU*3;\n        x += cos(r)*10;\n        y += sin(r)*10;\n        p = pow(0.95, i);\n        if(i > 50) alpha = 0;\n        stroke((m + i * 2)%255, (y), (x - i), alpha);\n        strokeWeight(60);\n        rect(x , y, width*p, p*height, 30, 30);\n        m += 0.01;\n        alpha -= 1;\n    }\n}"
    }

  },
  {
    "id": "A72",
    "title": "twisted_line_sketch",
    "artist": "HouCoder",
    "year": "2020",
    "repoUrl": "https://github.com/HouCoder/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"],
      "interaction": ["none"],
      "outcome": ["visual","time_based"]
    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"twisted_line_sketch",
      "extension":".js",
      "content":"let colors;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  colors = [\n    color(255, 0, 0),\n    color(0, 255, 0),\n    color(0, 0, 255)\n  ];\n}\n\nfunction draw() {\n  // This is the default blending mode.\n  blendMode(BLEND);\n  noFill();\n\n  background(255);\n  blendMode(EXCLUSION);\n\n\n\n  for (let i = 0; i < 3; i++) {\n    stroke(colors[i]);\n    strokeWeight(20);\n\n    //è¦æ³¨æ„beginshapeå’Œendshapeçš„ä½ç½®\n    beginShape();\n    for (let x = -20; x < width+20; x += 20) {\n      let y = height / 2;\n      //y=sin(x), xè¶Šå¤§ï¼Œå‘¨æœŸè¶ŠçŸ­ï¼Œç›¸åŒé•¿åº¦å†…é¢‘çŽ‡æ›´å¤§\n      //y=sin(x+a),aä¸ºæ­£æ•°æ—¶ï¼Œæ›²çº¿å‘å·¦å¹³ç§»\n      //i * TWO_PI / 3 æŽ§åˆ¶æ¯ä¸ªæ­£å¼¦å‡½æ•°æ ¹æ®içš„å˜åŒ–ï¼Œåœ¨ä¸åŒçš„ä½ç½®\n      //y=Asin(x) æŒ¯å¹…ï¼ˆçºµåæ ‡ï¼‰å˜ä¸ºåŽŸæ¥çš„Aå€\n      y += 200 * sin(x * 0.03 + frameCount * 0.06 + i * TWO_PI / 3) * pow(abs(sin(x*0.0015+frameCount * 0.01)),5);\n      curveVertex(x, y);\n\n    }\n    endShape();\n\n  }\n\n}"
      }

  },
  {
    "id": "A73",
    "title": "vector_perlin_polarC_sketch",
    "artist": "HouCoder",
    "year": "2020",
    "repoUrl": "https://github.com/HouCoder/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"vector_perlin_polarC_sketch",
      "extension":".js",
      "content":"let noiseScale = 300;\nlet num = 300;\nlet particles_1 = [];\nlet particles_2 = [];\nlet particles_3 = [];\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight);\n  background('#33658a');\n  // background(187, 148, 87);\n  for (let i = 0; i < num; i++) {\n    particles_1[i] = new Particle(random(0, width), random(0, height));\n    particles_2[i] = new Particle(random(0, width), random(0, height));\n    particles_3[i] = new Particle(random(0, width), random(0, height));\n  }\n}\n\nfunction draw() {\n  noStroke();\n \n  for (let i = 0; i < num; i++) {\n    \n    let r = map (i, 0,num,0.8,1.8);\n    let alpha = map (i, 0,num,0,200);\n\n    // fill(111, 29, 27,alpha);\n    fill(134, 187, 216,alpha);\n    particles_1[i].move();\n    particles_1[i].display(r);\n    particles_1[i].edges();\n    \n    // fill(67, 40, 24,alpha);\n    fill(246, 174, 45,alpha);\n    particles_2[i].move();\n    particles_2[i].display(r);\n    particles_2[i].edges();\n    \n    // fill(153, 88, 42,alpha);\n    fill(242, 100, 25,alpha);\n    particles_3[i].move();\n    particles_3[i].display(r);\n    particles_3[i].edges();\n  }\n}\n\nfunction Particle(x, y) {\n  this.dir = createVector(0, 0);\n  this.vel = createVector(0, 0);\n  this.pos = createVector(x, y);\n  this.speed = 0.4;\n\n  this.move = function() {\n    let angle = noise(this.pos.x / noiseScale, this.pos.y / noiseScale) * TWO_PI*noiseScale;\n    this.dir.x = cos(angle);\n    this.dir.y = sin(angle);\n    this.vel = this.dir.copy();\n    this.vel.mult(this.speed);\n    this.pos.add(this.vel);\n\n  }\n\n  this.edges = function() {\n    if (this.pos.x < 0 || this.pos.x > width || this.pos.y < 0 || this.pos.y > height) {\n      this.pos.x = random(0,width);\n      this.pos.y = random(0,height);\n    }\n  }\n\n  this.display = function(r) {\n    ellipse(this.pos.x, this.pos.y, r, r);\n  }\n\n}"
      }
  },
  {
    "id": "A74",
    "title": "watercolor_paint_sketch",
    "artist": "Abhi-Gautam",
    "year": "2020",
    "repoUrl": "https://github.com/Abhi-Gautam/Creative-Coding",
    "classification":{
      "material_and_processes": ["synthesized_image", "randomness"], 
      "interaction": ["none"], 
      "outcome": ["visual", "time_based"]

    },
    "description": "A generative landscape created using Perlin noise.",
    "llm_notes": "Relies on Perlin noise to produce smooth organic shapes resembling a landscape.",
    "metadata":{
      "file_name":"watercolor_paint_sketch",
      "extension":".js",
      "content":"brushes = [];\nleaves = 2;\n\n\n\nfunction setup() {\n    createCanvas(window.innerWidth, window.innerHeight);\n    background(255);\n    for(let i = 0; i < 15; i++)\n    {\n        brushes.push(new Brush());\n    }\n}\n\nfunction draw() {\n    for(let brush of brushes)\n        brush.paint();\n}\n\nclass Brush {\n    constructor() {\n        this.angle = random(TWO_PI);\n        this.x = random(width);\n        this.y = random(height);\n        this.clr = color(random(255), random(255), random(255), 15);\n        this.components = [];\n        for(let i = 0; i < leaves; i++) this.components.push(random(1, 5));\n    }\n\n    paint() {\n        let a = 0; \n        let r = 0;\n        let x1 = this.x;\n        let y1 = this.y;\n\n        let u = random(0.5, 0.6);\n\n        fill(this.clr);\n        noStroke();\n        beginShape();\n        while (a < TWO_PI) {\n            vertex(x1, y1);\n            let v = random(0.85, 1);\n            x1 = this.x + r * cos(this.angle + a) * u * v;\n            y1 = this.y + r * sin(this.angle + a) * u * v;\n            a += PI / 180;\n            for (let i = 0; i < leaves; i++) {\n                r += sin(a * this.components[i]);\n            }\n        }\n        endShape(CLOSE);\n\n        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {\n            this.angle += HALF_PI;\n        }\n\n        this.x += 2*cos(this.angle);\n        this.y += 2*sin(this.angle);\n        this.angle += random(-0.15, 0.15);\n    }\n}"
    }
  }
]
